<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/soarblog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/soarblog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/soarblog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/soarblog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/soarblog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/soarblog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/soarblog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="CASPP," />










<meta name="description" content="计算机系统漫游  计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。 现在就要开始一次有趣的漫游历程了。如果你全力投身">
<meta property="og:type" content="article">
<meta property="og:title" content="第一章 计算机系统漫游">
<meta property="og:url" content="https://soarspaces.github.io/soarblog/2021/03/29/CSAPP-chapter-one/index.html">
<meta property="og:site_name" content="肥肥小站">
<meta property="og:description" content="计算机系统漫游  计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。 现在就要开始一次有趣的漫游历程了。如果你全力投身">
<meta property="og:locale">
<meta property="og:image" content="https://static01.imgkr.com/temp/79f20dd9bd2742eb8ae03ac83224bf4d.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/197f0da67ee64d098803fa57bf4f44d6.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/20880fa56f2943a69caf3ed1d3d9a061.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/cf4bab5a89154842bac1b22695cbd2dd.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/3b431233e8534c99807d08b5137f1c5c.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/255346a57b2a4db09158e8b5e578d977.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/aec883c239dc4050af5bb3b4112fc931.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/0955c089e1524372885caddca9323342.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/15c815d24d714827b8c777363b62a09d.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/7f39fda6051d48dfbb93fefba4217977.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/4bb5d79fde224c5384fca2bf08fa8343.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/2705deeb10454235ad718446256e15d2.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/f4c403dcd4074e8a9367cdcfb6009a9c.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/3a7ea55c8c054ba1b700a86f37b2c766.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/574db1150bb842b0ba4a4db004bc022b.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/f24237d57c444a8a91a48c4dc36829a7.png">
<meta property="og:image" content="https://static01.imgkr.com/temp/a9e7f121bf9d4b5580b0c9f94106c83b.png">
<meta property="article:published_time" content="2021-03-29T09:47:15.000Z">
<meta property="article:modified_time" content="2021-04-02T03:49:14.275Z">
<meta property="article:author" content="soar spaces">
<meta property="article:tag" content="CASPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static01.imgkr.com/temp/79f20dd9bd2742eb8ae03ac83224bf4d.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://soarspaces.github.io/soarblog/2021/03/29/CSAPP-chapter-one/"/>





  <title>第一章 计算机系统漫游 | 肥肥小站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?48682526fbe6ada4d660fb5db2c37e53";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/soarblog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">肥肥小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">白话计算机</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/soarblog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/soarblog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/soarblog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/soarblog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://soarspaces.github.io/soarblog/soarblog/2021/03/29/CSAPP-chapter-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/soarblog/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肥肥小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第一章 计算机系统漫游</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-29T17:47:15+08:00">
                2021-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/soarblog/categories/computer/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/soarblog/2021/03/29/CSAPP-chapter-one/" class="leancloud_visitors" data-flag-title="第一章 计算机系统漫游">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong><center>计算机系统漫游</center></strong></p>
<hr>
<p><code>计算机系统</code>是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。</p>
<p>现在就要开始一次有趣的漫游历程了。如果你全力投身学习本书中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛”的道路。</p>
<p>你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。你将学会怎样通过一些小窍门来优化自己的 C 代码，以充分利用现代处理器和存储器系统的设计。你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。你将学会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。你将学会如何编写自己的 Unix shell、自己的动态存储分配包，甚至于自己的 Web 服务器。你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。</p>
<p>在<code>Kernighan</code>和<code>Ritchie</code>的关于 C 编程语言的经典教材中，他们通过图 1-1 中所示的 hello 程序来向读者介绍 C。尽管 hello 程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行 hello 程序时，系统发生了什么以及为什么会这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">———————————————————————————— code/intro/hello.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">———————————————————————————— code/intro/hello.c</span><br></pre></td></tr></table></figure>
<p>图 1-1 hello 程序</p>
<p>我们通过跟踪 hello 程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。</p>
<h1 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h1><p>hello程序的生命周期是从一个<code>源程序</code>（或者说<code>源文件</code>）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。</p>
<p>大部分的现代计算机系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的<a href="&quot;有其他编码方式用于表示非英语类语言文本。具体讨论参见2.1.4节的旁注。&quot;" title="其他编码">单字节大小的整数值</a>来表示每个字符。比如，图1-2 中给出了hello.c程序 的ASCII码表示。</p>
<p><img src="https://static01.imgkr.com/temp/79f20dd9bd2742eb8ae03ac83224bf4d.png" alt="图1-2 hello.c的ASCII文本表示"></p>
<p>hello.c 程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是35,它对应的就是字符 “#”。第二个字节的整数值为105,它对应的字符是‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符‘\n’来结束的，它所对应的整数值为10。像 hello.c 这样只由 ASCII 字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p>
<blockquote>
<p><strong>旁注 C 编程语言的起源</strong></p>
<p>C 语言是贝尔实验室的Dennis Ritchie于1969年〜1973年间创建的。美国国家标准学会 (American National Standards Institute, ANSI)在1989年颁布了 ANSI C 的标准，后来 C 语言的标准化成了国际标准化组织 (International Standards Organization，ISO) 的责任。这些标准定义了 C 语言和一系列函数库，即所谓的<code>C标准库</code>。Kernighan 和 Ritchie 在他们的经典著作中描述了 ANSI C，这本著作被人们满怀感情地称为 “K&amp;R”。用 Ritchie 的话来说，C 语言是“古怪的、有缺陷的，但同时也是一个巨大的成功”。为什么会成功呢？ </p>
<ul>
<li><strong>C语言与Unix操作系统关系密切</strong>。C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 内核(操作系统的核心部分)，以及所有支撑工具和函数库都是用C语言编写的。20世纪70年代后期到80年代初期，Unix 风行于高 等院校，许多人开始接触C语言并喜欢上它。因为 Unix 几乎全部是用C编写的，它可以很方便地移植到新的机器上，这种特点为 C 和 Unix 赢得了更为广泛的支持。</li>
<li><strong>C语言小而简单</strong>。C 语言的设计是由一个人而非一个协会掌控的，因此这是一个简洁明了、没有什么冗赘的设计。K&amp;R 这本书用大量的例子和练习描述了完整的 C 语言及其标准库，而全书不过261页。C 语言的简单使它相对而言易于学习，也易于移植到不同的计算机上。</li>
<li><strong>C语言是为实践目的设计的</strong>。C 语言是设计用来实现 Unix 操作系统的。后来，其他人发现能够用这门语言无障碍地编写他们想要的程序。</li>
</ul>
<p>C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成程序员困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象的显式支持，例如类、对象和异常。像 C++ 和 Java 这样针对应用级程序的新程序语言解决了这些问题。</p>
</blockquote>
<h1 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h1><p>hello 程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。</p>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>在这里，GCC 编译器驱动程序读取源程序文件 hello.c 并把它翻译成一个可执行目标文件 hello 这个翻译过程可分为四个阶段完成，如图1-3所示。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）。</p>
<p><img src="https://static01.imgkr.com/temp/197f0da67ee64d098803fa57bf4f44d6.png" alt="图1-3 编译系统"></p>
<ul>
<li><p><code>预处理阶段。</code>预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第1行的 #include<stdio.h> 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。</p>
</li>
<li><p><code>编译阶段。</code>编译器（ccl）将文本文件hello.i翻译成文本文件 hello.s，它包含一个汇编语言程序。该程序包含函数main的定义，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">  subq  $8, %rsp</span><br><span class="line">  movl  $.LCO, %edi</span><br><span class="line">  call  puts</span><br><span class="line">  movl  $0, %eax</span><br><span class="line">  addq  $8, %rsp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure></li>
<li><p>定义中2~7行的每行语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。</p>
</li>
<li><p><code>汇编阶段。</code>接下来，汇编器 (as) 将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序 (relocatable object program) 的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的17个字节是函数 main 的指令编码。如果我们在文本编辑器中打开 hello.o 文件，将看到一堆乱码。</p>
</li>
<li><p>·<code>链接阶段。</code>请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器 (Id) 就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件(或者简称为可执行文件)，可以被加载到内存中，由系统执行。</p>
</li>
</ul>
<hr>
<blockquote>
<p><strong>旁注 GNU项目</strong></p>
<p>GCC 是 GNU(GNU是GNU’s Not Unix的缩写) 项目开发出来的众多有用工具之一。GNU 项目是1984年由 Richard Stallman 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改和传播。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括EMACS编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括 C、C++、Fortran、Java、Pascal、面向对象C语言 (Objective-C) 和 Ada。</p>
<p>GNU 项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动(通常和Linux联系在一起)的思想起源是GNU项目中自由软件 (free software) 的概念。(此处的free<br>为自由言论 (free speech) 中的“自由”之意，而非免费啤酒(free beer)中的“免费”之意。)而且，Linux 如此受欢迎在很大程度上还要归功于 GNU 工具，它们给 Linux 内核提供了环境。</p>
</blockquote>
<h1 id="1-3-了解编译系统如何工作是大有益处的"><a href="#1-3-了解编译系统如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统如何工作是大有益处的"></a>1.3 了解编译系统如何工作是大有益处的</h1><p>对于像 hello.c 这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。</p>
<ul>
<li><p><code>优化程序性能。</code> 现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在 C 程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的 C 语句转化为机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else 语句高效得多？一个函数调用的开销有多大？ while 循环比 for 循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？<br>在第3章中，我们将介绍X86-64,最近几代 Linux、Macintosh 和 Windows 计算机的机器语言。我们会讲述编译器是怎样把不同的C语言结构翻译成这种机器语言的。在第5章中，你将学习如何通过简单转换 C 语言代码，帮助编译器更好地完成工作，从而调整 C 程序的性能。在第6章中，你将学习存储器系统的层次结构特性，C 语言编译器如何将数组存放在内存中，以及 C 程序又是如何能够利用这些知识从而更高效地运行。</p>
</li>
<li><p><code>理解链接时出现的错误。</code>根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？在第7章中，你将得到这些问题的答案。</p>
</li>
<li><p><code>避免安全漏洞。</code> 多年来，缓冲区溢出错误是造成大多数网络和 Internet 服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第3章中描述堆栈原理和缓冲区溢出错误。我们还将学习程序员、编译器和操作系统可以用来降低攻击威胁的方法。</p>
</li>
</ul>
<h1 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h1><p>此刻，hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello,并被存放在磁盘上。要想在 Unix 系统上运行该可执行文件，我们将它的文件名输入到称为 shell 的应用程序中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./hello</span></span><br><span class="line">hello, world</span><br><span class="line"><span class="meta">linux&gt;</span></span><br></pre></td></tr></table></figure><br>shell 是一个命令行解释器，它输出一个提示符，等待输人一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell将加载并运行 hello 程序，然后等待程序终止。hello 程序在屏幕上输出它的消息，然后终止。shell 随后输出一个提示符，等待下一个输人的命令行。</p>
<h2 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h2><p>为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组织，如<br>图1-4所示。这张图是近期 Intel 系统产品族的模型，但是所有其他系统也有相同的外观和特性。现在不要担心这张图很复杂——我们将在本书分阶段对其进行详尽的介绍。</p>
<ol>
<li><p><strong>总线</strong><br><br><br>贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传<br>递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。本书中，我们不对字长做任何固定的假设。相反，我们将在需要明确定义的上下文中具体说明一个“字”是多大。</p>
</li>
<li><p><strong>I/0设备</strong><br><br><br>I/0（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个I/O设<br>备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序<br>的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序 hello 就存放在磁盘上。<br><br>每个I/O设备都通过一个<code>控制器</code>或<code>适配器</code>与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。<br><br>第6章会更多地说明磁盘之类的I/O设备是如何工作的。在第10章中，你将学习如何在应用程序中利用 Unix I/O接口访问设备。我们将特别关注网络类设备，不过这些技术对于其他设备来说也是通用的。</p>
</li>
</ol>
<p><img src="https://static01.imgkr.com/temp/20880fa56f2943a69caf3ed1d3d9a061.png" alt="图1-4 一个典型系统的硬件组成"></p>
<p><code>cpu：中央处理单元；ALU：算术/逻辑单元；PC：程序计数器；USB：通用串行总线</code></p>
<ol>
<li><p><strong>主存</strong><br><br><br>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从<br>物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与 C 程序变量相对应的数据项的大小是根据类型变化的。比如，在运行 Linux 的x86-64机器上，short 类型的数据需要2个字节，int 和 float 类型需要4个字节，而 long 和 double 类型需要8个字节。<br><br><br>第6章将具体介绍存储器技术，比如 DRAM 芯片是如何工作的，它们又是如何组合起来构成主存的。</p>
</li>
<li><p><strong>处理器</strong><br><br><br>中央处理单元（CPU）,简称<code>处理器</code>，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或<code>寄存器</code>），称为<code>程序计数器</code>（PC）。在任何时刻，<a href="&quot;pc也普遍地被用来作为“个人计算机”的缩写。然而，两者之间的区别应该可以很清楚地从上下文中看出来。&quot;" title="PC">PC</a>都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br><br><br>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。<br><br><br>这样的简单操作并不多，它们围绕着<code>主存</code>、<code>寄存器文件</code>(register file)和<code>算术/逻辑单元</code>(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个<br>寄存器都有唯一的名字。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。</p>
</li>
</ol>
<ul>
<li><strong>加载</strong>：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。 </li>
<li><strong>存储</strong>：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li><strong>操作</strong>：把两个寄存器的内容复制到 ALU, ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制到程序计数器 (PC) 中，以覆盖PC中原来的值。</li>
</ul>
<p>处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂<br>的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分<br>开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际<br>上是如何实现的。在第3章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽<br>象性。第4章将更详细地介绍处理器实际上是如何实现的。第5章用一个模型说明现代处<br>理器是如何工作的，从而能预测和优化机器语言程序的性能。</p>
<h2 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h2><p>前面简单描述了系统的硬件组成和操作，现在开始介绍当我们运行示例程序时到底发生了些什么。在这里必须省略很多细节，稍后会做补充，但是现在我们将很满意于这种整体上的描述。</p>
<p>初始时，shell 程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串<br>“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到内存中，如图1-5所示。</p>
<p><img src="https://static01.imgkr.com/temp/cf4bab5a89154842bac1b22695cbd2dd.png" alt="图1-5 从键盘上读取hello命令"></p>
<p>当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出成字符串“hello, world\n”。</p>
<p>利用直接存储器存取（DMA,将在第6章中讨论）技术，数据可以不通过处理器而直<br>接从磁盘到达主存。这个步骤如图1-6所示。</p>
<p><img src="https://static01.imgkr.com/temp/3b431233e8534c99807d08b5137f1c5c.png" alt="图1-6 从磁盘加载可执行文件到主存"></p>
<p>一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的main程序中的机器语言指令。这些指令将 “hello, world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如图1-7所示。</p>
<p><img src="https://static01.imgkr.com/temp/255346a57b2a4db09158e8b5e578d977.png" alt="图1-7 将输出字符串从存储器写到显示器"></p>
<h1 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h1><p>这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。hello 程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复制到主存；当处理器运行程序时，指令又从主存复制到处理器。相似地，数据串 “hello,world/n” 开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备。从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。</p>
<p>根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍。</p>
<p>类似地，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。</p>
<p>针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为<code>高速缓存存储器</code>（cache memory,简称为 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。图1-8展示了一个典型系统中的高速缓存存储器。位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。</p>
<p>一个容量为数十万到数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5〜10倍。L1和L2高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：LI、L2和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p>
<p><img src="https://static01.imgkr.com/temp/aec883c239dc4050af5bb3b4112fc931.png" alt="图1-8 高速缓存存储器"></p>
<p>本书得出的重要结论之一就是，意识到<code>高速缓存存储器</code>存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。你将在第6章里学习这些重要的设备以及如何利用它们。</p>
<h1 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h1><p>在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，如图1-9所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为L0。这里我们展示的是三层高速缓存L1到L3,占据存储器层次结构的第1层到第3层。主存在第4层，以此类推。</p>
<p><img src="https://static01.imgkr.com/temp/0955c089e1524372885caddca9323342.png" alt="图1-9 一个存储器层次结构的示例"></p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。</p>
<p>正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。第6章将更详细地讨论这个问题。</p>
<h1 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h1><p>让我们回到 hello 程序的例子。当 shell 加载和运行hello程序时，以及 hello 程序输出自己的消息时，shell 和 hello 程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如图1-10所示。所有应用程序对硬件的操作尝试都必须通过操作系统。</p>
<p><img src="https://static01.imgkr.com/temp/15c815d24d714827b8c777363b62a09d.png" alt="图1-10 计算机系统的分层视图"></p>
<p>操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序<br>提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个<br>基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。如图1-11所示，文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理<br>器、主存和I/O设备的抽象表示。我们将依次讨论每种抽象表示。</p>
<p><img src="https://static01.imgkr.com/temp/7f39fda6051d48dfbb93fefba4217977.png" alt="图1-11 操作系统提供的抽象表示"></p>
<blockquote>
<p><strong>旁注 Unix、Posix和标准Unix规范</strong></p>
<p>20世纪60年代是大型、复杂操作系统盛行的年代，比如IBM的 OS/360 和 Honeywell的 Multics 系统。OS/360 是历史上最成功的软件项目之一，而 Multics 虽然持续存在了多年，却从来没有被广泛应用过。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为考虑到该项目的复杂性和缺乏进展而于1969年退出。鉴于Mutics项目不愉快的经历，一群贝尔实验室的研究人员———— Ken Thompson、Dennis Ritchie、Doug Mcllroy 和Joe Ossanna,从1969年开始在DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的操作系统。这个新系统中的很多思想，比如层次文件系统、作为用户级进程的shell概念，都是来自于Multics,只不过在一个更小、更简单的程序包里实现。1970年，Brian Kernighan 给新系统命名为 “Unix”，这也是一个双关语，暗指 “Multics” 的复杂性。1973年用 C 重新编写其内核，1974年，Unix 开始正式对外发布［93］。</p>
<p>贝尔实验室以慷慨的条件向学校提供源代码，所以 Unix在大专院校里获得了很多支持并得以持续发展。最有影响的工作发生在20世纪70年代晚期到80年代早期，在美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和Internet协议，称为 Unix 4. xBSD(Berkeley Software Distribution)。与此同时，贝尔实验室也在发布自己的版本，称为 System V Unix。其他厂商的版本，比如Sun Microsystems的 Solaris 系统，则是从这些原始的 BSD 和 System V 版本中衍生而来。</p>
<p>20世纪80年代中期，Unix 厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同，麻烦也就随之而来了。为了阻止这种趋势，IEEE (电气和电子工程师协会)开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为“Posix”。结果就得到了一系列的标准，称作Posix标准。这套标准涵盖了很多方面，比如Unix系统调用的 C 语言接口、shell 程序和工具、线程及网络编程。最近，一个被称为“标准Unix规范”的独立标准化工作已经与 Posix —起创建了统一的 Unix 系统标准。这些标准化工作的结果是Unix版本之间的差异已经基本消失。</p>
</blockquote>
<h2 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h2><p>像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I/O设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p>
<p><code>进程</code>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而<code>并发运行</code>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的<code>多核</code>处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为<code>上下文切换</code>。为了简化讨论，我们只考虑包含一个CPU的<code>单处理器系统</code>的情况。我们会在1.9.2节中讨论<code>多处理器系统</code>。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<code>上下文</code>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。图1-12展示了示例hello程序运行场景的基本理念。</p>
<p>示例场景中有两个并发的进程：shell进程和hello进程。最开始，只有shell进程在运行，即等待命令行上的输人。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回<br>给它，shell进程会继续等待下一个命令行输人。</p>
<p>如图1-12所示，从一个进程到另一个进程的转换是由操作系统<code>内核(kernel)</code>管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的<code>系统调用(systemcall)</code>指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p>
<p><img src="https://static01.imgkr.com/temp/4bb5d79fde224c5384fca2bf08fa8343.png" alt="图1-12 进程的上下文切换"></p>
<p>实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。我们将在第8章中揭示这项工作的原理，以及应用程序是如何创建和控制它们的进程的。</p>
<h2 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h2><p>尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在1.9.2节中讨论这个问题。在第12章中，你将学习并发的基本概念，包括如何写线程化的程序。</p>
<h2 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h2><p><code>虚拟内存</code>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为<code>虚拟地址空间</code>。图1-13所示的是Linux进程的虚拟地址空间（其他Unix系统的设计也与此类似）。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。</p>
<p><img src="https://static01.imgkr.com/temp/2705deeb10454235ad718446256e15d2.png" alt="图1-13 进程的虚拟地址空间"></p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。在本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益的。我们从最低的地址开始，逐步向上介绍。</p>
<ul>
<li><code>程序代码和数据。</code>对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。在第7章我们研究链接和加载时，你会学习更多有关地址空间的内容。</li>
<li><code>堆。</code>代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。在第9章学习管理虚拟内存时，我们将更详细地研究堆。</li>
<li><code>共享库。</code>大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。在第7章介绍动态链接时，将学习共享库是如何工作的。</li>
<li><code>栈。</code>位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。在第3章中将学习编译器是如何使用栈的。</li>
<li><code>内核虚拟内存。</code>地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li>
</ul>
<p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。<em>基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</em> 第9章将解释它如何工作，以及为什么对现代系统的运行如此重要。</p>
<h2 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h2><p><code>文件</code>就是字节序列，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O的系统函数调用读写文件来实现的。</p>
<p>文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O 设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。你将在第10章中学习 Unix I/O。</p>
<blockquote>
<p><strong>旁注 Linux项目</strong></p>
<p>1991年8月，芬兰研究生 Linus Torvalds 谨慎地发布了一个新的类Unix的操作系统内核，内容如下。</p>
<p>来自：torvalds@klaava.Helsinki.FK(Linus Benedict Torvalds)</p>
<p>新闻组：comp.os.minix</p>
<p>主题：在minix中你最想看到什么？</p>
<p>摘要：关于我的新操作系统的小调查</p>
<p>时间：1991年8月25日20:57:08GMT</p>
<p>每个使用 minix 的朋友，你们好。</p>
<p>我正在做一个(免费的)用在386(486)AT上的操作系统(只是业余爱好，它不会像GNU那样庞大和专业)。这个想法自4月份就开始酝酿，现在快要完成了。我希望得到各位对minix的任何反馈意见，因为我的操作系统在某些方面与它相类似(其中包括相同的文件系统的物理设计(因为某些实际的原因))。</p>
<p>我现在已经移植了 bash(1.08) 和 gcc(1.40)，并且看上去能运行。这意味着我需要几个月的时间来让它变得更实用一些，并且，我想要知道大多数人想要什么特性。欢迎任何建议，但是我无法保证我能实现它们。:-)</p>
<p>Linus(torvalds@kruuna.helsinki.fi)</p>
<p>就像 Torvalds 所说的，他创建 Linux 的起点是 Minix,由 Andrew S.Tanenbaum出于教育目的开发的一个操作系统。</p>
<p>接下来，如他们所说，这就成了历史。Linux逐渐发展成为一个技术和文化现象。通过和 GNU 项目的力量结合，Linux 项目发展成了一个完整的、符合 Posix 标准的 Unix 操作系统的版本，包括内核和所有支撑的基础设施。从手持设备到大型计算机，Linux 在范围如此广泛的计算机上得到了应用。IBM 的一个工作组甚至把Linux移植到了一块腕表中！</p>
</blockquote>
<h1 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h1><p>系统漫游至此，我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上，现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备，如图1-14所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="https://static01.imgkr.com/temp/f4c403dcd4074e8a9367cdcfb6009a9c.png" alt="图1-14 网络也是一种I/O设备"></p>
<p>随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和 telnet 这样的应用都是基于网络复制信息的功能。</p>
<p>回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello 程序。假设用本地主机上的 <code>telnet 客户端</code>连接远程主机上的 <code>telnet 服务器</code>。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输人命令。此后在远端运行 hello 程序包括如图1-15所示的五个基本步骤。</p>
<p><img src="https://static01.imgkr.com/temp/3a7ea55c8c054ba1b700a86f37b2c766.png" alt="图1-15 利用telnet通过网络远程运行hello"></p>
<p>当我们在telnet客户端键人“hello”字符串并敲下回车键后，客户端软件就会将这个字符串发送到telnet的服务器。telnet服务器从网络上接收到这个字符串后，会把它传递给远端shell程序。接下来，远端shell运行hello程序，并将输出行返回给telnet服务器。最后，telnet服务器通过网络把输出串转发给telnet客户端，客户端就将输出串输出到我们的本地终端上。</p>
<p>这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。在第11章中，你将学会如何构造网络应用程序，并利用这些知识创建一个简单的 Web 服务器。</p>
<h1 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h1><p>在此，小结一下我们旋风式的系统漫游。这次讨论得出一个很重要的观点，那就是系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。本书的余下部分会讲述硬件和软件的详细内容，通过了解这些详细内容，你可以写出更快速、更可靠和更安全的程序。</p>
<p>作为本章的结束，我们在此强调几个贯穿计算机系统所有方面的重要概念。我们会在本书中的多处讨论这些概念的重要性。</p>
<h2 id="1-9-1-Amdahl-定律"><a href="#1-9-1-Amdahl-定律" class="headerlink" title="1.9.1 Amdahl 定律"></a>1.9.1 Amdahl 定律</h2><p>Gene Amdahl,计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察被称为 Amdahl 定律 (Amdahl’s law)。该定律的主要思想是，当我们对系 统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为 $T_{old}$ 。假设系统某部分所需执行时间与该时间的比例为 $\alpha$，而该部分性能提升比例为 $\kappa$。 即该部分初始所需时间为 $\alpha\,T_{old}$,现在所需时间为 $\alpha\,T_{old}/\kappa$因此，总的执行时间应为</p>
<script type="math/tex; mode=display">T_{new}\,=\,(1-\alpha) T_{old}\,+\,\alpha T_{old}/\kappa\,=\,T_{old}\,[(1-\alpha)\,+\,\alpha/\kappa]</script><p>由此，可以计算加速比 $ S = T_{old}/T_{new}$ 为</p>
<script type="math/tex; mode=display">S\;=\; \frac {1} {(1-\alpha)\,+\,\alpha/\kappa}</script><p>举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为 60%(α=0.6),其加速比例因子为3(κ=3)。则我们可以获得的加速比为 1/[0.4+0.6/3]=1.67倍。虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是 Amdahl 定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p>
<blockquote>
<p><strong>旁注 表示相对性能</strong></p>
<p>性能提升最好的表示方法就是用比例的形式 $T_{old}/T_{new}$，其中，$T_{old}$ 为原始系统所需时间，$T_{new}$ 为修改后的系统所需时间。如果有所改进，则比值应大于1。我们用后缀“Х”来表示比例，因此，“2.2Х” 读作 “2.2倍”。</p>
<p>表示相对变化更传统的方法是用百分比，这种方法适用于变化小的情况，但其定义是模糊的。应该等于 $100 \cdot (T_{old}-T_{new})/T_{new}$，还是$100 \cdot (T_{old}-T_{new})/T_{old}$，还是其他的值？此外，它对较大的变化也没有太大意义。与简单地说性能提升2.2X相比，“性能提升了120%”更难理解。</p>
</blockquote>
<ul>
<li>✍ <code>练习题1.1</code> 假设你是个卡车司机，要将土豆从爱达荷州的 Boise 运送到明尼苏达州的 Minneapolis,全程2500公里。在限速范围内，你估计平均速度为100公里/小时，整个行程需要25个小时。<ul>
<li>A.你听到新闻说蒙大拿州刚刚取消了限速，这使得行程中有1500公里卡车的速度可以为150公里/小时。那么这对整个行程的加速比是多少？</li>
<li>B.你可以在 www.fasttrucks.com 网站上为自己的卡车买个新的涡轮增压器。网站现货供应各种型号，不过速度越快，价格越高。如果想要让整个行程的加速比为1.67X,那么你必须以多快的速度通过蒙大拿州？</li>
</ul>
</li>
<li>✍<code>练习题1.2</code> 公司的市场部向你的客户承诺，下一个版本的软件性能将改进2X。这项任务被分配给你。你已经确认只有80%的系统能够被改进，那么，这部分需要被改进多少(即κ取何值)才能达到整体性能目标？</li>
</ul>
<p>Amdahl定律一个有趣的特殊情况是考虑 κ 趋向于∞时的效果。这就意味着，我们可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。<br>于是我们得到</p>
<script type="math/tex; mode=display">S_\infty \;=\; \frac {1}{(1-\alpha)}</script><p>举个例子，如果 60% 的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有 1/0.4=2.5X。</p>
<p>Amdahl定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低刀片制造成本，或学生想要提高自己的绩点平均值等方面。也许它在计算机世界里是最有意义的，在这里我们常常把性能提升2倍或更高的比例因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。</p>
<h2 id="1-9-2-并发与并行"><a href="#1-9-2-并发与并行" class="headerlink" title="1.9.2 并发与并行"></a>1.9.2 并发与并行</h2><p>数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的术语<code>并发(concurrency)</code>是一个通用的概念，指一个同时具有多个活动的系统；而术语<code>并行(parallelism)</code>指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。</p>
<ol>
<li><strong>线程级并发</strong><br><br><br>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。自20世纪60年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。这种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个Web服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启Web浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为<code>单处理器系统</code>。<br><br><br>当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个<code>多处理器系统</code>。其实从20世纪80年代开始，在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和<code>超线程(hyperthreading)</code>的出现，这种系统才变得常见。图1-16给出了这些不同处理器类型的分类。</li>
</ol>
<p><img src="https://static01.imgkr.com/temp/574db1150bb842b0ba4a4db004bc022b.png" alt="图1-16 不同的处理器配置分类。随着多核处理器和超线程的出现，多处理器变得普遍了"></p>
<p>多核处理器是将多个CPU(称为“核”)集成到一个集成电路芯片上。图1-17 描述的是一个典型多核处理器的组织结构，其中微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中的L1高速缓存分为两个部分———— 一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能够将几十个、最终会是上百个核做到一个芯片上。</p>
<p><img src="https://static01.imgkr.com/temp/f24237d57c444a8a91a48c4dc36829a7.png" alt="图1-17 多核处理器的组织结构。4个处理器核集成在一个芯片上"></p>
<p>超线程，有时称为<code>同时多线程(simultaneous multi-threading)</code>,是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。举例来说，Intel Core i7 处理器可以让每个核执行两个线程，所以一个4核的系统实际上可以并行地执行8个线程。</p>
<p>多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过50年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。第12章会更深人地探讨并发，以及使用并发来提供处理器资源的共享，使程序的执行允许有更多的并行。</p>
<ol>
<li><p>指令级并行<br><br><br>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，如 1978 年的 Intel 8086,需要多个(通常是3~10个)时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期2~4条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约20个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达100条指令。在第4章中，我们会研究<code>流水线(pipelining)</code>的使用。在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的执行速率。<br><br><br>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量(superscalar)处理器。大多数现代处理器都支持超标量操作。第5章中，我们将描述超标量处理器的高级模型。应用程序员可以用这个模型来理解程序的性能。然后，他们就能写出拥有更高程度的指令级并行性的程序代码，因而也运行得更快。</p>
</li>
<li><p>单指令、多数据并行<br><br><br>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为<code>单指令、多数据</code>，即 SIMD 并行。例如，较新几代的Intel和AMD处理器都具有并行地对8对单精度浮点数( C数据类型 float )做加法的指令。<br><br><br>提供这些 SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从 C 程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。作为对第5章中比较通用的程序优化描述的补充，我们在网络旁注 OPT:SIMD 中描述了这种编程方式。</p>
</li>
</ol>
<h1 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h1><p><code>抽象</code>的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口(API)就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如Java类的声明和C语言的函数原型。</p>
<p>我们已经介绍了计算机系统中使用的几个抽象，如图1-18所示。在处理器里，<code>指令集架构</code>提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。</p>
<p><img src="https://static01.imgkr.com/temp/a9e7f121bf9d4b5580b0c9f94106c83b.png" alt="图1-18 计算机系统提供的一些抽象。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性"></p>
<p>在学习操作系统时，我们介绍了三个抽象：文件是对 I/O 设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象：虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是IBM在20世纪60年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统 (例如，MicrosoftWindows、MacOS 和 Linux) 或同一操作系统的不同版本设计的程序。</p>
<p>在本书后续的章节中，我们会具体介绍这些抽象。</p>
<h1 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h1><p>计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。</p>
<p>处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构—— CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化 C 程序的性能。</p>
<p>操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1) 文件是对I/O 设备的抽像；2) 虚拟内存是对主存和磁盘的抽象；3) 进程是处理器、主存和 I/O 设备的抽象。</p>
<p>最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O设备。</p>
<h3 id="练习题答案"><a href="#练习题答案" class="headerlink" title="练习题答案"></a>练习题答案</h3><ol>
<li>1 该问题说明Amdahl定律不仅仅适用于计算机系统。<ul>
<li>A. 根据公式1.1，有 α = 0.6, κ = 1.5。更直接地说，在蒙大拿行驶的1500公里需要10个小时，而其他行程也需要10个小时。则加速比为 25/(10+10) = 1.25X。</li>
<li>B. 根据公式1.1 ,有 α = 0.6，要求 S = l.67，则可算出κ。更直接地说，要使行程加速度达到1.67X，我们必须把全程时间减少到15个小时。蒙大拿以外仍要求为10小时，因此，通过蒙大拿的时间就为5个小时。这就要求行驶速度为300公里/小时，对卡车来说这个速度太快了！</li>
</ul>
</li>
<li>2 理解 Amdahl 定律最好的方法就是解决一些实例。本题要求你从特殊的角度来看公式1.1。<br><br><br>本题是公式的简单应用。已知 S = 2， α = 0.8，则计算κ：<script type="math/tex; mode=display">\qquad\qquad\quad\quad 2 \;=\; \frac {1}{(1 - 0.8) \, + \, 0.8/\kappa}</script><script type="math/tex; mode=display">\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\! 0.4 + 1.6 / \kappa \; = \; 1.0</script><script type="math/tex; mode=display">\kappa \; = \; 2.67</script></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/soarblog/tags/caspp/" rel="tag"># CASPP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/soarblog/2021/03/29/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="gitalk-container"></div>
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/soarblog/images/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!-- <a href="/soarblog/archives/%7C%7Carchive">-->
				<a href="/soarblog/archives">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/soarblog/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/soarblog/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-1-%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">1.</span> <span class="nav-text">1.1 信息就是位+上下文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-2-%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">1.2 程序被其他程序翻译成不同的格式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-3-%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84"><span class="nav-number">3.</span> <span class="nav-text">1.3 了解编译系统如何工作是大有益处的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-4-%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">1.4 处理器读并解释储存在内存中的指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-1-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><span class="nav-number">4.1.</span> <span class="nav-text">1.4.1 系统的硬件组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-2-%E8%BF%90%E8%A1%8Chello%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.2.</span> <span class="nav-text">1.4.2 运行hello程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-5-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81"><span class="nav-number">5.</span> <span class="nav-text">1.5 高速缓存至关重要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-6-%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">1.6 存储设备形成层次结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6"><span class="nav-number">7.</span> <span class="nav-text">1.7 操作系统管理硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-1-%E8%BF%9B%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">1.7.1 进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-2-%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">1.7.2 线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">7.3.</span> <span class="nav-text">1.7.3 虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-4-%E6%96%87%E4%BB%B6"><span class="nav-number">7.4.</span> <span class="nav-text">1.7.4 文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-8-%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E5%88%A9%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">8.</span> <span class="nav-text">1.8 系统之间利用网络通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-9-%E9%87%8D%E8%A6%81%E4%B8%BB%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">1.9 重要主题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-1-Amdahl-%E5%AE%9A%E5%BE%8B"><span class="nav-number">9.1.</span> <span class="nav-text">1.9.1 Amdahl 定律</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-2-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">9.2.</span> <span class="nav-text">1.9.2 并发与并行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-9-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">1.9.3 计算机系统中抽象的重要性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-10-%E5%B0%8F%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">1.10 小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">11.0.1.</span> <span class="nav-text">练习题答案</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">soar spaces</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/soarblog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/soarblog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/soarblog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/soarblog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/soarblog/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/soarblog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/soarblog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/soarblog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  













<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: 'soarspaces',
            repo: 'soargitment',
            clientID: '00814b1ad431b7a93bc5',
            clientSecret: '04192f43cdc2d2c0f9a65060bf84193a25e3d6ed',
            admin: 'soarspaces',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("vxRHngT8QMETbXIgL4WQIX5h-gzGzoHsz", "aFEhragJAcBUbaKWXqQIxWB2");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
