<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/soarblog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/soarblog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/soarblog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/soarblog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/soarblog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/soarblog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/soarblog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="用有趣的文字，记录解读计算机世界">
<meta property="og:type" content="website">
<meta property="og:title" content="肥肥小站">
<meta property="og:url" content="https://soarspaces.github.io/soarblog/index.html">
<meta property="og:site_name" content="肥肥小站">
<meta property="og:description" content="用有趣的文字，记录解读计算机世界">
<meta property="og:locale">
<meta property="article:author" content="soar spaces">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://soarspaces.github.io/soarblog/"/>





  <title>肥肥小站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?48682526fbe6ada4d660fb5db2c37e53";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/soarblog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">肥肥小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">白话计算机</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/soarblog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/soarblog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/soarblog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/soarblog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://soarspaces.github.io/soarblog/soarblog/2021/04/08/CASPP-chapter-two-part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/soarblog/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肥肥小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/soarblog/2021/04/08/CASPP-chapter-two-part1/" itemprop="url">第二章 信息的表示和处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-08T16:04:51+08:00">
                2021-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/soarblog/categories/computer/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/soarblog/2021/04/08/CASPP-chapter-two-part1/" class="leancloud_visitors" data-flag-title="第二章 信息的表示和处理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>我们对计算机系统的探索是从学习计算机本身开始的，它由处理器和存储器子系统组成。在核心部分，我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何操作这样的数据，以及编译器又如何将c程序翻译成这样的指令。接下来，研究几种实现处理器的方法，帮助我们更好地了解硬件资源如何被用来执行指令。一旦理解了编译器和机器级代码，我们就能了解如何通过编写C程序以及编译它们来最大化程序的性能。本部分以存储器子系统的设计作为结束，这是现代计算机系统最复杂的部分之一。</p>
<p>本书的这一部分将领着你深入了解如何表示和执行应用程序。你将学会一些技巧，来帮助你写出安全、可靠且充分利用计算资源的程序。</p>
<hr>
<h1 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h1><p>现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为位 (bit)，形成了数字革命的基础。大家熟悉并使用了1000多年的十进制 (以10为基数) 起源于印度，在12世纪被阿拉伯数学家改进，并在13世纪被意大利数学家 Leonardo Pisano (大约公元1170—1250，更为大家所熟知的名字是Fibonacci) 带到西方。对于有10个手指的人类来说，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机器时，二进制值工作得更好。二值信号能够很容易地被表示、存储和传输，例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。</p>
<p>孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种<code>解释 (interpretation)</code>，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对文档中的字母和符号进行编码。在本章中，我们将讨论这两种编码，以及负数表示和实数近似值的编码。</p>
<p>我们研究三种最重要的数字表示。无符号 (unsigned) 编码基于传统的二进制表示法，表示大于或者等于零的数字。补码 (two’s-complement) 编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。浮点数 (floating-point) 编码是表示实数的科学记数法的以 2 为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加法和乘法，类似于对应的整数和实数运算。</p>
<p>计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出 (overflow)。溢出会导致某些令人吃惊的后果。例如，在今天的大多数计算机上 (使用 32 位来表示数据类型 int)，计算表达式 200<em>300</em>400*500 会得出结果 -884901888。这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。</p>
<p>另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利<br>用乘法的结合律和交换律，计算下面任何一个C表达式，都会得出结果一884901888：</p>
<p>(500 <em> 400) </em> (300 * 200)</p>
<p>((500 <em> 400) </em> 300) * 200</p>
<p>((200 <em> 500) </em> 300) * 400</p>
<p>400 <em> (200 </em> (300 * 500))</p>
<p>计算机可能没有产生期望的结果，但是至少它是一致的！</p>
<p>浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值+∞，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。例如，在大多数机器上，C表达式 (3.14+le20) - le20 求得的值会是 0.0，而 3.14 + (le20-le20) 求得的值会是3.14。整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同——整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。</p>
<p>通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了解这种属性是非常重要的。后面我们会讲到，大量计算机的安全漏洞都是由于计算机算术运算的微妙细节引发的。在早期，当人们碰巧触发了程序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们的程序如何工作，以及如何被迫产生不良的行为。</p>
<p>计算机用几种不同的二进制表示形式来编码数值。随着第3章进人机器级编程，你需要熟悉这些表示方式。在本章中，我们描述这些编码，并且教你如何推出数字的表示。通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。</p>
<p>我们对这部分内容的处理是基于一组核心的数学原理的。从编码的基本定义开始，然后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。我们相信从这样一个抽象的观点来分析这些内容，对你来说是很重要的，因为程序员需要对计算机运算与更为人熟悉的整数和实数运算之间的关系有清晰的理解。</p>
<blockquote>
<p><strong>旁注 怎样阅读本章</strong></p>
<p>本章我们研究在计算机上如何表示数字和其他形式数据的基本属性，以及计算机对这些数据执行操作的属性。这就要求我们深入研究数学语言，编写公式和方程式，以及展示重要属性的推导。</p>
<p>为了帮助你阅读，这部分内容安排如下：首先给出以数学形式表示的属性，作为原理。然后，用例子和非形式化的讨论来解释这个原理。我们建议你反复阅读原理描述和它的示例与讨论，直到你对该属性的说明内容及其重要性有了牢固的直觉。对于更加复杂的属性，还会提供推导，其结构看上去将会像一个数学证明。虽然最终你应该尝试理解这些推导，但在第一次阅读时你可以跳过它们。</p>
<p>我们也鼓励你在阅读正文的过程中完成练习题，这会促使你主动学习，帮助你理论联系实际。有了这些例题和练习题作为背景知识，再返回推导，你将发现理解起来会容易许多。同时，请放心，掌握好高中代数知识的人都具备理解这些内容所需要的数学技能。</p>
</blockquote>
<p>C++ 编程语言建立在 C 语言基础之上，它们使用完全相同的数字表示和运算。本章中关于 C 的所有内容对 C++ 都有效。另一方面，Java 语言创造了一套新的数字表示和运算标准。C 标准的设计允许多种实现方式，而Java标准在数据的格式和编码上是非常精确具体的。本章中多处着重介绍了Java支持的表示和运算。</p>
<blockquote>
<p><strong>旁注 C编程语言的演变</strong></p>
<p>前面提到过，C 编程语言是贝尔实验室的 Dennis Ritchie 最早开发出来的，目的是和 Unix 操作系统一起使用（Unix也是贝尔实验室开发的）。在那个时候，大多数系统程序，例如操作系统，为了访问不同数据类型的低级表示，都必须大量地使用汇编代码。比如说，像malloc库函数提供的内存分配功能，用当时的其他高级语言是无法编写的。</p>
<p>Brian Kernighan和 Dennis Ritchie 的著作的第1版记录了最初贝尔实验室的 C 语言版本。随着时间的推移，经过多个标准化组织的努力，C 语言也在不断地演变。1989 年，美国国家标准学会下的一个工作组推出了 ANSIC 标准，对最初的贝尔实验室的 C 语言做了重大修改。ANSIC 与贝尔实验室的 C 有了很大的不同，尤其是函数声明的方式。Brian Kernighan 和 Dennis Ritchie 在著作的第 2 版中描述了 ANSIC,这本书至今仍被公认为关于 C 语言最好的参考手册之一。</p>
<p>国际标准化组织接替了对 C 语言进行标准化的任务，在 1990 年推出了一个几乎和ANSIC 一样的版本，称为 “ISO C90”。该组织在 1999 年又对 C 语言做了更新，推出 “ISO C99”。在这一版本中，引入了一些新的数据类型，对使用不符合英语语言字符的文本字符串提供了支持。更新的版本2011年得到批准，称为 “ISO C11”，其中再次添加了更多的数据类型和特性。最近增加的大多数内容都可以向后兼容，这意味着根据早期标准(至少可以回溯到ISO C90)编写的程序按新标准编译时会有同样的行为。</p>
<p>GNU 编译器套装(GNU Compiler Collection，GCC) 可以基于不同的命令行选项，依照多个不同版本的C语言规则来编译程序，如图2-1所示。比如，根据 ISO Cl1来编译程序prog.c，我们就使用命令行<br><br>  <code>linux&gt; gcc-std=cllprog.c</code></p>
<p><img src="https://static01.imgkr.com/temp/e4835bb6fc8e4d34a6a6bc80c77f2486.png" alt="图2-1 向GCC指定不同的C语言版本"></p>
<p>编译选项 -ansi 和 -std=c89 的用法是一样的 —— 会根据ANSI或者 ISO C90 标准来编译程序。(C90有时也称为 “C89”，这是因为它的标准化工作是从1989年开始的。)编译选项 -std=c99 会让编译器按照 ISO C99 的规则进行编译。</p>
<p>本书中，没有指定任何编译选项时，程序会按照基于 ISO C90 的 C 语言版本进行编译，但是也包括一些 C99、C11 的特性，一些 C++ 的特性，还有一些是与 GCC 相关的特性。GNU 项目正在开发一个结合了 ISO C11 和其他一些特性的版本，可以通过命令行选项 -std=gnul1 来指定。(目前，这个实现还未完成。)今后，这个版本会成为默认的版本。</p>
</blockquote>
<h1 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h1><p>大多数计算机使用8位的块，或者<code>字节 (byte)</code>，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为<code>虚拟内存 (virtual memory)</code>。内存的每个字节都由一个唯一的数字来标识，称为它的<code>地址 (address)</code>，所有可能地址的集合就称为<code>虚拟地址空间(virtual address space)</code>。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现(见第9章)是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。</p>
<p>在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的<code>程序对象 (program object)</code>，即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C 语言中一个指针的值(无论它指向一个整数、一个结构或是某个其他程序对象)都是某个存储块的第一个字节的虚拟地址。C 编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管 C 编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。</p>
<blockquote>
<p><strong>给C语言初学者 C语言中指针的作用</strong></p>
<p>指针是 C 语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。</p>
<p>真正理解指针需要查看它们在机器级上的表示以及实现。这将是第3章的重点之一，3.10.1节将对其进行深入介绍。</p>
</blockquote>
<h2 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2. 1. 1 十六进制表示法"></a>2. 1. 1 十六进制表示法</h2><p>一个字节由8位组成。在二进制表示法中，它的值域是 $00000000_2〜11111111_2$。如果看成十进制整数，它的值域就是$0_{10}〜255_{10}$。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以16为基数，或者叫做十六进制（hexadecimal）数，来表示位模式。十六进制（简写为“hex”）使用数字 ‘0’〜‘9’ 以及字符 ‘A’〜‘F’ 来表示16个可能的值。图2-2展示了16个十六进制数字对应的十进制值和二进制值。用十六进制书写，一个字节的值域为$00_{16}〜FF_{16}$。</p>
<p><img src="https://static01.imgkr.com/temp/9dbcfe2772834b08aa159d589eef41ee.png" alt="图2-2 十六进制表示法。每个十六进制数字都对16个值中的一个进行了编码
"></p>
<p>在C语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 ‘A’〜‘F’ 既可以是大写，也可以是小写。例如，我们可以将数字$FA1D37B_{16}$写作 0xFA1D37B，或者 0xfa1d37b，甚至是大小写混合，比如，0xFa1D37b。在本书中，我们将使用C表示法来表品十六进制值。</p>
<p>编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以一次执行一个十六进制数字的转换。数字的转换可以参考如图2-2所示的表。一个简单的窍门是，记住十六进制数字 A、C 和 F 相应的十进制值。而对于把十六进制值 B、D 和 E 转换成十进制值，则可以通过计算它们与前三个值的相对关系来完成。</p>
<p>比如，假设给你一个数字 0xl73A4C。可以通过展开每个十六进制数字，将它转换为二进制格式，如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">十六进制</th>
<th style="text-align:center">1</th>
<th style="text-align:center">7</th>
<th style="text-align:center">3</th>
<th style="text-align:center">A</th>
<th style="text-align:center">4</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">二进制</td>
<td style="text-align:center">0001</td>
<td style="text-align:center">0111</td>
<td style="text-align:center">0011</td>
<td style="text-align:center">1010</td>
<td style="text-align:center">0100</td>
<td style="text-align:center">1100</td>
</tr>
</tbody>
</table>
</div>
<p>这样就得到了二进制表示000101110011101001001100。<br>反过来，如果给定一个二进制数字1111001010110110110011,可以通过首先把它分为每4位一组来转换为十六进制。不过要注意，如果位总数不是4的倍数，最左边的一组可以少于4位，前面用0补足。然后将每个4位组转换为相应的十六进制数字： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">二进制</th>
<th style="text-align:center">11</th>
<th style="text-align:center">1100</th>
<th style="text-align:center">1010</th>
<th style="text-align:center">1101</th>
<th style="text-align:center">1011</th>
<th style="text-align:center">0011</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:center">3</td>
<td style="text-align:center">C</td>
<td style="text-align:center">A</td>
<td style="text-align:center">D</td>
<td style="text-align:center">B</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>✍ <code>练习题2. 1</code> 完成下面的数字转换：<br><br>  A. 将0x39A7F8转换为二进制。<br><br>  B. 将二进制1100100101111011转换为十六进制。<br><br>  C. 将0xD5E4C转换为二进制。<br><br>  D. 将二进制1001101110011110110101转换为十六进制。<br></li>
</ul>
<p>当值 χ 是 2 的非负整数 n 次幂时，也就是$χ=2^n$ 我们可以很容易地将 χ 写成十六进制形式，只要记住 χ 的二进制表示就是1后面跟 n 个 0。十六进制数字 0 代表4个二进制 0。所以，当 n 表示成 i + 4j 的形式，其中 0≤i≤3，我们可以把 χ 写成开头的十六进制数字为 1(i=0)、2(i=1)、4(i=2)或者8(i=3)，后面跟随着 j 个十六进制的0。比如，$χ=2048=2^{11}$，我们有 n=11=3 + 4 * 2，从而得到十六进制表示 0x800。</p>
<ul>
<li>✍ <code>练习题2.2</code> 填写下表中的空白项，给出2的不同次幂的二进制和十六进制表示：<br></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">n</th>
<th style="text-align:center">$2^n$(十进制)</th>
<th style="text-align:center">$2^n$(十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">512</td>
<td style="text-align:center">0x200</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">16384</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0x10000</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">32</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0x80</td>
</tr>
</tbody>
</table>
</div>
<p>十进制和十六进制表示之间的转换需要使用乘法或者除法来处理一般情况。将一个十进制数字 χ 转换为十六进制，可以反复地用 16 除 χ，得到一个商 q 和一个余数 r，也就是 χ = q * 16 + r。然后，我们用十六进制数字表示的 r 作为最低位数字，并且通过对 q 反复<br>进行这个过程得到剩下的数字。例如，考虑十进制 314 156的转换：</p>
<script type="math/tex; mode=display">314156 = 19634 - 16 +12  (C)</script><script type="math/tex; mode=display">19 634= 1227 \cdot 16+2 (2)</script><script type="math/tex; mode=display">1227= 76 \cdot 16 +11 (B)</script><script type="math/tex; mode=display">76= 4 - 16 + 12 (C)</script><script type="math/tex; mode=display">4= 0 \cdot 16 +4 (4)</script><p>从这里，我们能读出十六进制表示为 0x4CB2C。</p>
<p>反过来，将一个十六进制数字转换为十进制数字，我们可以用相应的16的幂乘以每个十六进制数字。比如，给定数字 0x7AF,我们计算它对应的十进制值为 $ 7 \cdot 16^2 + 10 \cdot<br>16 +15 = 7 \cdot 256 + 10 \cdot 16 +15 = 1792+160+15 =1967$ </p>
<ul>
<li>✍ <code>练习题2.3</code> 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制值： </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制</th>
<th style="text-align:center">二进制</th>
<th style="text-align:center">十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0000 0000</td>
<td style="text-align:center">0x00</td>
</tr>
<tr>
<td style="text-align:center">167</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">188</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0011 0111</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">1000 1000</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">1111 0011</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0x52</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">OxAC</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0xE7</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>旁注 十进制和十六进制间的转换</strong><br>较大数值的十进制和十六进制之间的转换，最好是让计算机或者计算器来完成。有大量的工具可以完成这个工作。一个简单的方法就是利用任何标准的搜索引擎，比如查询：</p>
<p>把0xabcd转换为十进制数</p>
<p>或</p>
<p>把123用十六进制表示。</p>
</blockquote>
<ul>
<li>✍ <code>练习题2.4</code> 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六进制表示。提示：只要将执行十进制加法和减法所使用的方法改成以16为基数。<br><br>A. 0x503c+0x8=<br><br>B. 0x503c-0x40=<br><br>C. 0x503c+64=<br><br>D. 0x50ea-0x503c=<br></li>
</ul>
<h2 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h2><p>每台计算机都有一个字长 (word size),指明指针数据的标称大小 (nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器而言，虚拟地址的范围为 $0 \backsim 2^W-1$,程序最多访问 $2^w$ 个字节。</p>
<p>最近这些年，出现了大规模的从32位字长机器到64位字长机器的迁移。这种情况首先出现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在智能手机的处理器上。32位字长限制虚拟地址空间为4千兆字节(写作4GB),也就是说，刚刚超过 $4 \times 10^9$ 字节。扩展到 64 位字长使得虚拟地址空间为 16EB，大约是 $1.84 \times 10^{19}$ 字节。</p>
<p>大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容。因此，举例来说，当程序prog.c用如下伪指令编译后</p>
<p><code>linux&gt; gcc -m32 prog.c</code></p>
<p>该程序就可以在32位或64位机器上正确运行。另一方面，若程序用下述伪指令编译</p>
<p><code>linux&gt; gcc -m64 prog.c</code></p>
<p>那就只能在64位机器上运行。因此，我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的， 而不是其运行的机器类型。</p>
<p>计算机和编译器支持多种不同方式编码的数字格式，如不同长度的整数和浮点数。比如，许多机器都有处理单个字节的指令，也有处理表示为2字节、4字节或者8字节整数的指令，还有些指令支持表示为4字节和8字节的浮点数。</p>
<p><img src="https://static01.imgkr.com/temp/a91688f8996a4d9d9a5195a219c7453c.png" alt="图2-3 基本 C 数据类型的典型大小(以字节为单位)。分配的字节数受程序是如何编译的影响而变化。本图给出的是32位和64位程序的典型值"></p>
<p>C语言支持整数和浮点数的多种数据格式。图2-3 展示了为 C 语言各种数据类型分配的字节数。（我们在2.2节讨论 C 标准保证的字节数和典型的字节数之间的关系。）有些数据类型的确切字节数依赖于程序是如何被编译的。我们给出的是32位和64位程序的典型值。整数或者为<code>有符号的</code>，即可以表示负数、零和正数；或者为<code>无符号的</code>，即只能表示非负数。C 的数据类型 char 表示一个单独的字节。尽管 “char” 是由于它被用来存储文本串中的单个字符这一事实而得名，但它也能被用来存储整数值。数据类型 short，int 和 long 可以提供各种数据大小。即使是为64位系统编译，数据类型 int 通常也只有 4 个字节。数据类型 long —般在 32位 程序中为 4 字节，在 64 位程序中则为 8 字节。</p>
<p>为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 int32_t 和 int64_t，它们分别为4个字节和8个字节。使用确定大小的整数类型是程序<br>员准确控制数据表示的最佳途径。</p>
<p>大部分数据类型都编码为有符号数值，除非有前缀关键字 unsigned 或对确定大小的<br>数据类型使用了特定的无符号声明。数据类型 char 是一个例外。尽管大多数编译器和机器将它们视为有符号数，但 C 标准不保证这一点。相反，正如方括号指示的那样，程序员应该用有符号字符的声明来保证其为一个字节的有符号数值。不过，在很多情况下，程序行为对数据类型 char 是有符号的还是无符号的并不敏感。</p>
<p>对关键字的顺序以及包括还是省略可选关键字来说，C 语言允许存在多种形式。比<br>如，下面所有的声明都是一个意思：</p>
<p>unsigned long</p>
<p>unsigned long int</p>
<p>long unsigned</p>
<p>long unsigned int</p>
<p>我们将始终使用图2-3给出的格式。</p>
<p>图2-3还展示了指针（例如一个被声明为类型为“char * ”的变量）使用程序的全字长。大多数机器还支持两种不同的浮点数格式：单精度（在 C 中声明为float）和双精度（在 C 中声明为 double）。这些格式分别使用4字节和8字节。</p>
<blockquote>
<p><strong>给C语言初学者 声明指针</strong><br>对于任何数据类型 $T$，声明<br>$T <em>p$;<br>表明 p 是一个指针变量，指向一个类型为 $T$ 的对象。例如，<br>$char </em>p$;<br>就将一个指针声明为指向一个char类型的对象。</p>
</blockquote>
<p>程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C 语言标准对不同数据类型的数字范围设置了下界（这点在后面还将讲到），但是却没有上界。因为从 1980 年左右到 2010 年左右，32 位机器和 32 位程序是主流的组合，许多程序的编写都假设为图2-3 中 32 位程序的字节分配。随着 64 位机器的日益普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就会显现出来，成为错误。比如，许多程序员假设一个声明为 int 类型的程序对象能被用来存储一个指针。这在大多数 32 位的机器上能正常工作，但是在一台 64 位的机器上却会导致问题。</p>
<h2 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h2><p>对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为 int 的变量 x 的地址为 0x100,也就是说，地址表达式 &amp;x 的值为 0xl00。那么，（假设数据类型 int 为 32 位表示）x 的 4 个字节将被存储在内存的 0x100、0x101、0x102 和 0x103 位置。</p>
<p>排列表示一个对象的字节有两个通用的规则。考虑一个 w 位的整数，其位表示为 $[x_{\omega-1}, x_{\omega-2},\cdots,x_1,x_0]$，其中 $x_{\omega-1}$ 是最高有效位，而 $x_0$ 最低有效位。假设 $\omega$ 是 8 的倍数，这些位就能被分组成为字节，其中最高有效字节包含位 $[x_{\omega-1},x_{\omega-2},\cdots,x_{\omega-8}]$，而最低有效字节包含位 $[x_7,x_6,\cdots,x_0]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为<code>小端法（little endian）</code>。后一种规则——最高有效字节在最前面的方式，称为<code>大端法（big endian）</code>。</p>
<p>假设变量 x 的类型为 int，位于地址0x100处，它的十六进制值为 0x01234567。地<br>址范围 0x100 ~ 0x103的字节顺序依赖于机器的类型：</p>
<p><img src="https://static01.imgkr.com/temp/5a5c9f1fb6464a6fa2256998636e84e9.png" alt=""></p>
<p>注意，在字 0x01234567 中，高位字节的十六进制值为 0x01，而低位字节值为 0x67。</p>
<p>大多数Intel兼容机都只用小端模式。另一方面，IBM 和 Oracle（从其2010年收购<br>Sun Microsystems开始）的大多数机器则是按大端模式操作。注意我们说的是“大多数”。这些规则并没有严格按照企业界限来划分。比如，IBM 和 Oracle 制造的个人计算机使用的是 Intel 兼容的处理器，因此使用小端法。许多比较新的微处理器是<code>双端法（bi-endian）</code>，也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是：一旦选择了特定操作系统，那么字节顺序也就固定下来。比如，用于许多移动电话的ARM微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统——Android（来自Google）和 IOS（来自Apple）却只能运行于小端模式。</p>
<p>令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上，术语 “little endian（小端）” 和 “big endian（大端）” 出自Jonathan Swift的《格利佛游记》（Gulliver’s Travels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，选择何种字节顺序没有技术上的理由，因此争论沦为关于社会政治论题的争论。只要选择了一种规则并且始终如一地坚持，对于哪种字节排序的选择都是任意的。</p>
<blockquote>
<p><strong>旁注 “端”的起源</strong></p>
<p>以下是 Jonathan Swift 在 1726 年关于大小端之争历史的描述:<br>“……我下面要告诉你的是，Lilliput 和 Blefuscu 这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由Blefuscu的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”(此段译文摘自网上蒋剑锋译的《格利佛游记》第一卷第4章。)</p>
<p>在他那个时代，Swift是在讽刺英国 (Lilliput) 和法国 (Blefuscu) 之间持续的冲突。Danny Cohen, 一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了。</p>
</blockquote>
<p>对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。我们将在第11章中看到这种转换的例子。</p>
<p>第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在检查机器级程序时。作为一个示例，从某个文件中摘出了下面这行代码，该文件给出了一个针对 Intel x86-64处理器的机器级代码的文本表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip)</span><br></pre></td></tr></table></figure><br>这一行是由<code>反汇编器(disassembler)</code>生成的，反汇编器是一种确定可执行程序文件所表示的指令序列的工具。我们将在第3章中学习有关这些工具的更多知识，以及怎样解释像这样的行。而现在，我们只是注意这行表述的意思是：十六进制字节串 01 05 43 0b 20 00 是一条指令的字节级表示，这条指令是把一个字长的数据加到一个值上，该值的存储地址由 0x200b43 加上当前程序计数器的值得到，当前程序计数器的值即为下一条将要执行指令的地址。如果取出这个序列的最后4个字节：43 0b 20 00，并且按照相反的顺序写出，我们得到 00 20 0b 43。去掉开头的 0，得到值0x200b43,这就是右边的数值。当阅读像此类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，这正好和通常书写数字时最高有效位在左边，最低有效位在右边的方式相反。</p>
<p>字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在 C 语言中，可以通过使用<code>强制类型转换 (cast)</code> 或<code>联合 (union)</code> 来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。</p>
<p>图2-4 展示了一段 C 代码，它使用强制类型转换来访问和打印不同程序对象的字节表示。我们用 typedef 将数据类型 byte_pointer 定义为一个指向类型为 “unsignedchar” 的对象的指针。这样一个字节指针引用一个字节序列，其中每个字节都被认为是一个非负整数。第一个例程 show_bytes 的输入是一个字节序列的地址，它用一个字节指针以及一个字节数来指示。该字节数指定为数据类型 size_t，表示数据结构大小的首选数据类型。show_bytes 打印出每个以十六进制表示的字节。C 格式化指令 “％.2x” 表明整数必须用至少两个数字的十六进制格式输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((bypte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图2-4 打印程序对象的字节表示。这段代码使用强制类型转换来规避类型系统。很容易定义针对其他数据类型的类似函数</p>
<p>过程 show_int、show_float 和 show_pointer 展示了如何使用程序 show_bytes 来分别输出类型为int、float和 void <em> 的 C 程序对象的字节表示。可以观察到它们仅仅传递给 show_bytes 一个指向它们参数 x 的指针 &amp;x，且这个指针被强制类型转换为 “unsigned char </em> ”。这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。然后，这个指针会被看成是对象使用的最低字节地址。</p>
<p>这些过程使用C语言的运算符 sizeof 来确定对象使用的字节数。一般来说，表达式 sizeof(T) 返回存储一个类型为 T 的对象所需要的字节数。使用 sizeof 而不是一个固定的值，是向编写在不同机器类型上可移植的代码迈进了一步。</p>
<p>在几种不同的机器上运行如图2-5 所示的代码，得到如图2-6 所示的结果。我们使用<br>了以下几种机器：</p>
<p>Linux 32：运行 Linux 的 Intel IA32 处理器。</p>
<p>Windows：运行 Windows 的 Intel IA32 处理器。</p>
<p>Sun：运行Solaris的 Sun Microsystems SPARC 处理器。(这些机器现在由Oracle生产。)</p>
<p>Linux 64：运行 Linux 的 Intel x86-64 处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------- code/data/show-bytes.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>) ival;</span><br><span class="line">    <span class="keyword">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------- code/data/show-bytes.c</span><br></pre></td></tr></table></figure>
<p>图2-5 字节表示的示例，这段代码打印示例数据对象的字节表示</p>
<p><img src="https://static01.imgkr.com/temp/b7a71e18c7c04bd7ba8a9f9674196c6e.png" alt="图2-6 不同数据值的字节表示。除了字节顺序以外，int和float的结果是一样的。指针值与机器相关"></p>
<p>参数12345的十六进制表示为 0x00003039。对于int类型的数据，除了字节顺序以外，我们在所有机器上都得到相同的结果。特别地，我们可以看到在 Linux32、Windows 和 Linux64上，最低有效字节值0x39最先输出，这说明它们是小端法机器；而在Sun 上最后输出，这说明Sun是大端法机器。同样地，float 数据的字节，除了字节顺序以外，也都是相同的。另一方面，指针值却是完全不同的。不同的机器/操作系统配置使用不同的存储分配规则。一个值得注意的特性是 Linux32、Windows 和 Sun的机器使用 4 字节地址，而 Linux64 使用8字节地址。</p>
<blockquote>
<p><strong>给C语言初学者 使用 typedef 来命名数据类型</strong></p>
<p>C 语言中的 typedef 声明提供了一种给数据类型命名的方式。这能够极大地改善代<br>码的可读性，因为深度嵌套的类型声明很难读懂。</p>
<p>typedef的语法与声明变量的语法十分相像，除了它使用的是类型名，而不是变量名。因此，图2-4 中 byte_pointer 的声明和将一个变量声明为类型 “unsigned char * ”有相同的形式。</p>
<p>例如，声明：</p>
<p>typedef int *int_pointer;</p>
<p>int_pointer ip;</p>
<p>将类型 “int_pointer” 定义为一个指向int的指针，并且声明了一个这种类型的变量 ip。我们还可以将这个变量直接声明为：</p>
<p>int *ip;</p>
<p><strong>给 C 语言初学者 使用 printf格式化输出</strong></p>
<p>printf函数（还有它的同类 fprintf 和 sprintf ）提供了一种打印信息的方式，这种方式对格式化细节有相当大的控制能力。第一个参数是格式串（format string）,而其余的参数都是要打印的值。在格式串里，每个以 “％” 开始的字符序列都表示如何格式化下一个参数。典型的示例包括：‘%d’ 是输出一个十进制整数，‘％f’ 是输出一个浮点数，而 ‘％c’ 是输出一个字符，其编码由参数给出。</p>
<p>指定确定大小数据类型的格式，如 int32_t，要更复杂一些，相关内容参见 2.2.3 节的旁注。</p>
</blockquote>
<p>可以观察到，尽管浮点型和整型数据都是对数值12345编码，但是它们有截然不同的<br>字节模式：整型为 0x00003039，而浮点数为 0x4640E400。一般而言，这两种格式使用不同的编码方法。如果我们将这些十六进制模式扩展为二进制形式，并且适当地将它们移位，就会发现一个有13个相匹配的位的序列，用一串星号标识出来：</p>
<script type="math/tex; mode=display">
\begin{matrix}
    0   & 0  & 0  & 0  & 3  & 0  & 3  & 9  &    &    &     \\
    0000&0000&0000&0000&0011&0000&0011&1001&    &    &     \\
        &    &    &    & *  &****&****&****&    &    &      \\
        &    &    &  4 & 6  & 4  & 0  & E  & 4  & 0  & 0    \\
        &    &  01&0001&1001&0000&0011&1001&0000&0000&00    \\
\end{matrix}</script><p>这并不是巧合。当我们研究浮点数格式时，还将再回到这个例子。</p>
<blockquote>
<p><strong>给 C 语言初学者 指针和数组</strong></p>
<p>在函数 show_bytes（图2-4）中，我们看到指针和数组之间紧密的联系，这将在 3.8 节中详细描述。这个函数有一个类型为 byte_pointer（被定义为一个指向 unsigned char 的指针）的参数 start，但是我们在第 8 行上看到数组引用start[i]。在 C 语言中，我们能够用数组表示法来引用指针，同时我们也能用指针表示法来引用数组元素。在这个例子中，引用 start[i] 表示我们想要读取以 start 指向的位置为起始的第i个位置处的字节。</p>
<p><strong>给 C 语言初学者 指针的创建和间接引用</strong><br>在图2-4的第 13、17和 21 行，我们看到对 C 和 C++ 中两种独有操作的使用。C 的“取地址”运算符 &amp; 创建一个指针。在这三行中，表达式 &amp;x 创建了一个指向保存变量 x 的位置的指针。这个指针的类型取决于 x 的类型，因此这三个指针的类型分别为int<em>、float</em> 和 void<em>*。（数据类型 void </em> 是一种特殊类型的指针，没有相关联的类型信息。）</p>
<p>强制类型转换运算符可以将一种数据类型转换为另一种。因此，强制类型转换（byte_pointer） &amp;x 表明无论指针 &amp;x 以前是什么类型，它现在就是一个指向数据类型为 unsigned char 的指针。这里给出的这些强制类型转换不会改变真实的指针，它们只是告诉编译器以新的数据类型来看待被指向的数据。</p>
<p><strong>旁注 生成一张ASCII表</strong></p>
<p>可以通过执行命令 man ascii 来得到一张ASCII字符码的表。</p>
</blockquote>
<ul>
<li><p>✍ <code>练习题2.5</code> 思考下面对 show_bytes 的三次调用：<br><br>int val = 0x87654321;<br><br>byte_pointer valp = (byte_pointer) &val;<br><br>show_bytes(valp, 1); /<em> A. </em>/ <br><br>show_bytes(valp, 2); /<em> B. </em>/ <br><br>show_bytes(valp, 3); /<em> C. </em> / <br><br>指出在小端法机器和大端法机器上，每次调用的输出值。<br><br>A. 小端法：     大端法：       <br><br>B. 小端法：     大端法：       <br><br>C. 小端法：     大端法：       <br></p>
</li>
<li><p>✍ <code>练习题2.6</code> 使用show_int 和 show_float，我们确定整数 3510593 的十六进制表示为 0x00359141，而浮点数 3510593.0 的十六进制表示为 0x4A564504。<br><br>A. 写出这两个十六进制值的二进制表示。<br><br>B. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？<br><br>C. 串中的什么部分不相匹配？<br></p>
</li>
</ul>
<h2 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h2><p>C 语言中字符串被编码为一个以 null(其值为0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。因此，如果我们以参数 “12345” 和 6 (包括终止符)来运行例程 show_bytes，我们得到结果 31 32 33 34 35 00。请注意，十进制数字 x 的 ASCII 码正好是 0x3x，而终止字节的十六进制表示为 0x00。在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。</p>
<ul>
<li>✍ <code>练习题 2.7</code> 下面对 show_bytes 的调用将输出什么结果？<br><br>const char *s = “abcdef”;<br>show_bytes((byte_pointer) s, strlen(s));</li>
</ul>
<blockquote>
<p><strong>旁注 文字编码的Unicode标准</strong></p>
<p>ASCII 字符集适合于编码英语文档，但是在表达一些特殊字符方面并没有太多办法，例如法语的 “Ç”。它完全不适合编码希腊语、俄语和中文等语言的文档。这些年，提出了很多方法来对不同语言的文字进行编码。Unicode 联合会 (Unicode Consortium) 修订了最全面且广泛接受的文字编码标准。当前的 Unicode 标准(7.0版)的字库包括将近 100000 个字符，支持广泛的语言种类，包括古埃及和巴比伦的语言。为了保持信用，Unicode 技术委员会否决了为 Klingon（即电视连续剧《星际迷航》中的虚构文明）编写语言标准的提议。</p>
<p>基本编码，称为 Unicode 的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占用 4 个字节。不过，可以有一些替代编码，常见的字符只需要 1 个或 2 个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8 表示将每个字符编码为一个字节序列，这样标准 ASCII 字符还是使用和它们在 ASCII 中一样的单字节编码，这也就意味着所有的 ASCII 字节序列用 ASCII 码表示和用 UTF-8 表示是一样的。</p>
<p>Java 编程语言使用 Unicode 来表示字符串。对于 C 语言也有支持 Unicode 的程序库。</p>
</blockquote>
<h2 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h2><p>考虑下面的 C 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们在示例机器上编译时，生成如下字节表示的机器代码：</p>
<script type="math/tex; mode=display">
\begin{matrix}
Linux &32&55&89&e5&8b&45&0c&03&45&08&c9&c3 \\
Windows &55&89&e5&8b&45&0c&03&45&08&5d&c3 \\
Sun  &81&c3 &e0 &08 &90 &02 &00 &09 \\
Linux &64  &55 &48 &89 &e5 &89 &7d &fc &89 &75 &f8 &03 &45 &fc &c9 &c3 \\
\end{matrix}</script><p>我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<p>计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。在第3章学习机器级编程时，我们将更清楚地看到这一点。</p>
<h2 id="2-1-6布尔代数简介"><a href="#2-1-6布尔代数简介" class="headerlink" title="2.1.6布尔代数简介"></a>2.1.6布尔代数简介</h2><p>二进制值是计算机编码、存储和操作信息的核心，所以围绕数值 0 和 1 的研究已经演化出了丰富的数学知识体系。这起源于 1850 年前后乔治•布尔(George Boole，1815-1864) 的工作，因此也称为<code>布尔代数(Booleanalgebra)</code>。布尔注意到通过将逻辑值 TRUE(真)和 FALSE(假)编码为二进制值 1 和 0，能够设计出一种代数，以研究逻辑推理的基本原则。</p>
<p><img src="https://static01.imgkr.com/temp/32c225d021c34ccfa58973db271714b0.png" alt="图2-7 布尔代数的运算。二进制值 1 和 0 表示逻辑值 TRUE 或者 FALSE，而运算符~、&amp;、| 和^分别表示逻辑运算 NOT、AND、OR 和 EXCLUSIVE-OR"></p>
<p>最简单的布尔代数是在二元集合 {0,1} 基础上的定义。图2-7 定义了这种布尔代数中的几种运算。我们用来表示这些运算的符号与 C 语言位级运算使用的符号是相匹配的，这些将在后面讨论到。布尔运算 ~ 对应于逻辑运算 NOT，在命题逻辑中用符号 ﹁ 表示。也就是说，当 P 不是真的时候，我们就说 ﹁P 是真的，反之亦然。相应地，当 P 等于 0 时，~P 等于 1，反之亦然。布尔运算 &amp; 对应于逻辑运算 AND，在命题逻辑中用符号 ∧ 表示。当 P 和 Q 都为真时，我们说 P ∧ Q 为真。相应地，只有当 p=1 且 q=1 时，p&amp;q 才等于 1。布尔运算 | 对应于逻辑运算 OR，在命题逻辑中用符号 ∨ 表示。当 P 或者 Q 为真时，我们说 P ∨ Q 成立。相应地，当 p=1 或者 q=1 时，p|q 等于1。布尔运算 ^ 对应于逻辑运算异或，在命题逻辑中用符号 ㊉ 表示。当 P 或者 Q 为真但不同时为真时，我们说 P㊉Q 成立。相应地，当 p=1 且 q=0,或者 p=0 且 q=1 时，p^q 等于1。</p>
<p>后来创立信息论领域的 Claude Shannon(1916—2001)首先建立了布尔代数和数字逻辑之间的联系。他在 1937 年的硕士论文中表明了布尔代数可以用来设计和分析机电继电器网络。尽管那时计算机技术已经取得了相当的发展，但是布尔代数仍然在数字系统的设计和分析中扮演着重要的角色。</p>
<p>我们可以将上述4个布尔运算扩展到<code>位向量</code>的运算，位向量就是固定长度为 w、由 0 和 1 组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。假设 a 和 b 分别表示位向量 $[a_{w-1},a_{w-2},\cdots,a_0]$ 和 $[b_{w-1},b_{w-2},\cdots,b_0]$。我们将 $ a \\&amp; b $ 也定义为一个长度为 w 的位向量，其中第$i$个元素等于$a_i\\&amp;b_i, 0 \leqslant i&lt;w $。可以用类似的方式将运算 |、^ 和 ~ 扩展到位向量上。</p>
<p>举个例子，假设 w=4，参数 a=[0110]，b=[1100]。那么4种运算 a&amp;b、a|6、a^b 和 ~b 分别得到以下结果：</p>
<script type="math/tex; mode=display">
\begin{array}{cccc}
  \begin{array}{cc}
      & 0110 \\
     \& & 1100 \\ 
    \hline
      & 0100 \\
   \end{array}
   &
   \begin{array}{cc}
      & 0110 \\
     \mid & 1100 \\ 
    \hline
      & 1110 \\
   \end{array}
    &
   \begin{array}{cc}
      & 0110 \\
     \hat\ & 1100 \\ 
    \hline
      & 1010 \\
   \end{array}
    &
   \begin{array}{cc}
      & 0110 \\
     \backsim & 1100 \\ 
    \hline
      & 1110 \\
   \end{array}
 \end{array}</script><ul>
<li>✍ <code>练习题2.8</code> 填写下表，给出位向量的布尔运算的求值的求值结果。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">[01101001]</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">[01010101]</td>
</tr>
<tr>
<td style="text-align:center">~a</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">~b</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">a&amp;b</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">a &#124; b</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">a^b</td>
<td style="text-align:center">——</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>网络旁注 DATA:BOOL 关于布尔代数和布尔环的更多内容</strong></p>
<p>对于任意整数 w&gt;0，长度为 w 的位向量上的布尔运算 |、&amp; 和 ~ 形成了一个布尔代数。最简单的情况是 w=l 时，只有 2 个元素；但是对于更普遍的情况，有 $2^W$ 个长度为 w 的位向量。布尔代数和整数算术运算有很多相似之处。例如，乘法对加法的分配律，写为 a•(b+c)=(a•b)+(a•c)，而布尔运算 &amp;对 | 的分配律，写为 a&amp;(b|c)=(a&amp;b|(a&amp;c)。此外，布尔运算 | 对 &amp; 也有分配律，写为 a|(b&amp;c)=(a|b)&amp;(a|c)，但是对于整数我们不能说 a+(b•c)=(a+b)•(a+c)。</p>
<p>当考虑长度为 w 的位向量上的 ^、&amp; 和 ~ 运算时，会得到一种不同的数学形式，我们称为布尔环(Boolean ring)。布尔环与整数运算有很多相同的属性。例如，整数运算的一个属性是每个值 $X$ 都有一个加法逆元(additive inverse)—$x$，使得 $x+(—x)=0$。布尔环也有类似的属性，这里的“加法”运算是^，不过这时每个元素的加法逆元是它自己本身。也就是说，对于任何值 a 来说，a^a=0,这里我们用 0 来表示全 0 的位向量。可以看到对单个位来说这是成立的，即 0^0=1^1=0，将这个扩展到位向量也是成立的。当我们重新排列组合顺序，这个属性也仍然成立，因此有(a^b)^a=b。这个属性会引起一些很有趣的结果和聪明的技巧，在练习题2.10中我们会有所探讨。</p>
</blockquote>
<p>位向量一个很有用的应用就是表示有限集合。我们可以用位向量$[a_{w-1},\cdots,a_1,a_0]$。编码任何子集 $A \subseteq {0,1,\cdots,w-1}$，其中$a_i=1$当且仅当 $ i\in A$。例如(记住我们是把 $a_{w-1}$ 写在左边，而将 $a_0$ 写在右边)，位向量$ a=[01101001]$ 表示集合 $A=\lbrace 0,3,5,6 \rbrace$，而 b = [01010101]表示集合 $B= \lbrace 0,2,4,6 \rbrace $。使用这种编码集合的方法，布尔运算 | 和 &amp; 分别对应于集合的并和交，而~对应于于集合的补。还是用前面那个例子，运算 a&amp;b 得到位向量 $[01000001]$，而 $A\cap B={0,6}$。</p>
<p>在大量实际应用中，我们都能看到用位向量来对集合编码。例如，在第8章，我们会看到有很多不同的<code>信号</code>会中断程序执行。我们能够通过指定一个位向量掩码，有选择地使能或是屏蔽一些信号，其中某一位位置上为 1 时，表明信号 $i$ 是有效的(使能)，而 0 表明该信号是被屏蔽的。因而，这个掩码表示的就是设置为有效信号的集合。</p>
<ul>
<li>✍ <code>练习题2.9</code> 通过混合三种不同颜色的光（红色、绿色和蓝色），计算机可以在视频屏幕或者液晶显示器上产生彩色的画面。设想一种简单的方法，使用三种不同颜色的光，每种光都能打开或关闭，投射到玻璃屏幕上，如图所示：<br><br><img src="https://static01.imgkr.com/temp/a2c11958355344b6a1ded8ff5e7b5523.png" alt=""><br>那么基于光源R（红）、G（绿）、B（蓝）的关闭（0）或打开（1），我们就能够创建8种不同的颜色：<br><img src="https://static01.imgkr.com/temp/88740de329f5446b8c7855eb72ddbfd4.png" alt=""><br>这些颜色中的每一种都能用一个长度为3的位向量来表示，我们可以对它们进行布尔运算。<br><ul>
<li>A.一种颜色的补是通过关掉打开的光源，且打开关闭的光源而形成的。那么上面列出的 8 种颜色每一种的补是什么？</li>
<li>B. 描述下列颜色应用布尔运算的结果：<br><br>蓝色 | 绿色 = <br><br>黄色 &amp; 蓝绿色 = <br><br>红色 ^ 红紫色 = <br></li>
</ul>
</li>
</ul>
<h2 id="2-1-7-C-语言中的位级运算"><a href="#2-1-7-C-语言中的位级运算" class="headerlink" title="2.1.7 C 语言中的位级运算"></a>2.1.7 C 语言中的位级运算</h2><p>C语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使<br>用的那些符号就是 C 语言所使用的：| 就是 OR（或），&amp;就是 AND（与），~ 就是 NOT（取反），而 ^ 就是 EXCLUSIVE-OR（异或）。这些运算能运用到任何“整型”的数据类型上，包括图2-3 所示内容。以下是一些对 char 数据类型表达式求值的例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">C的表达式</th>
<th style="text-align:center">二进制表达式</th>
<th style="text-align:center">二进制结果</th>
<th style="text-align:center">十六进制结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~0x41</td>
<td style="text-align:center">~[0100 0001]</td>
<td style="text-align:center">[1011 1110]</td>
<td style="text-align:center">OxBE</td>
</tr>
<tr>
<td style="text-align:center">~0x00</td>
<td style="text-align:center">~[0000 0000]</td>
<td style="text-align:center">[1111 1111]</td>
<td style="text-align:center">OxFF</td>
</tr>
<tr>
<td style="text-align:center">0x69&amp;0x55</td>
<td style="text-align:center">[0110 1001]&amp;[0101 0101]</td>
<td style="text-align:center">[0100 0001]</td>
<td style="text-align:center">0x41</td>
</tr>
<tr>
<td style="text-align:center">0x69 &#124; 0x55</td>
<td style="text-align:center">[0110 1001] &#124; [0101 0101]</td>
<td style="text-align:center">[0111 1101]</td>
<td style="text-align:center">0x7D</td>
</tr>
</tbody>
</table>
</div>
<p>正如示例说明的那样，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。</p>
<ul>
<li><p>✍ <code>练习题2.10</code> 对于任一位向量a，有 a^a=0。应用这一属性，考虑下面的程序：<br></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplace_swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    *y = *x ^ *y;  <span class="comment">/* Step 1 */</span></span><br><span class="line">    *x = *x ^ *y;  <span class="comment">/* Step 2 */</span></span><br><span class="line">    *y = *x ^ *y;  <span class="comment">/* Step 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如程序名字所暗示的那样，我们认为这个过程的效果是交换指针变量x和y所指向的存储位置处存放的值。注意，与通常的交换两个数值的技术不一样，当移动一个值时，我们不需要第三个位置来临时存储另一个值。这种交换方式并没有性能上的优势，它仅仅是一个智力游戏。</p>
<p>以指针 x 和 y 指向的位置存储的值分别是 a 和 b 作为开始，填写下表，给出在程序的每一步之后，存储在这两个位置中的值。利用 ^ 的属性证明达到了所希望的效果。回想一下，每个元素就是它自身的加法逆元（a^a=0）。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">步骤</th>
<th style="text-align:center">*x</th>
<th style="text-align:center">*y</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">第1步</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">第2步</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">第3步</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>✍ <code>练习题2.11</code> 在练习题2.10中的inplace_swap函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> first, last;</span><br><span class="line"><span class="keyword">for</span> (first = <span class="number">0</span>, last = cnt<span class="number">-1</span>;</span><br><span class="line">    first &lt;= last;</span><br><span class="line">    first++,last--)</span><br><span class="line">    inplace_swap(&amp;a[first] , &amp;a[last]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你对一个包含元素 1、2、3和 4 的数组使用这个函数时，正如预期的那样，现在数组的元素变成了 4、3、2 和 1。不过，当你对一个包含元素 1、2、3、4 和 5 的数组使用这个函数时，你会很惊奇地看到得到数字的元素为 5、4、0、2 和 1。实际上，你会发现这段代码对所有偶数长度的数组都能正确地工作，但是当数组的长度为奇数时，它就会把中间的元素设置成0。<br></p>
<ul>
<li>A. 对于一个长度为奇数的数组，长度 cnt=2k+l，函数reverse_array 最后一次循环中，变量first和last的值分别是什么？<br></li>
<li>B. 为什么这时调用函数 inplace_swap 会将数组元素设置为0?<br></li>
<li>C. 对 reverse_array 的代码做哪些简单改动就能消除这个问题？<br></li>
</ul>
</li>
</ul>
<p>位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。让我们来看一个例子，掩码 0xFF（最低的8位为1）表示一个字的低位字节。位级运算 x&amp;0xFF 生成一个由 x 的最低有效字节组成的值，而其他的字节就被置为 0。比如，对于 x=0x89ABCDEF，其表达式将得到 0x000000EF。表达式 ~0 将生成一个全 1 的掩码，不管机器的字大小是多少。尽管对于一个32位机器来说，同样的掩码可以写成 0xFFFFFFFF,但是这样的代码不是可移植的。</p>
<ul>
<li><p>✍ <code>练习题2.12</code> 对于下面的值，写出变量 x 的 C 语言表达式。你的代码应该对任何字长 $w \geqslant 8$ 都能工作。我们给出了当 x=0x87654321 以及 $w=32$ 时表达式求值的结果，仅供参考。<br></p>
<ul>
<li>A. x 的最低有效字节，其他位均置为0。[0x00000021]。<br></li>
<li>B. 除了 x 的最低有效字节外，其他的位都取补，最低有效字节保持不变。[0x789ABC21]。<br></li>
<li>C. x 的最低有效字节设置成全 1，其他字节都保持不变。［0X876543FF］。</li>
</ul>
</li>
<li><p>✍ <code>练习题2.13</code> 从20世纪70年代末到80年代末，Digital Equipment 的 VAX 计算机是一种非常流行的机型。它没有布尔运算 AND 和 OR 指令，只有 bis(位设置)和 bic(位清除)这两种指令。两种指令的输入都是一个数据字 x 和一个掩码字 m。它们生成一个结果 z，z 是由根据掩码 m 的位来修改 x 的位得到的。使用bis指令，这种修改就是在 m 为 1 的每个位置上，将 z 对应的位设置为 1。使用 bic 指令，这种修改就是在 m 为 1 的每个位置，将 z 对应的位设置为 0。<br><br>为了看清楚这些运算与 C 语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 | 和 ^ 运算。填写下列代码中缺失的代码。提示：写出 bis 和 bic 运算的 C 语言表达式。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Declarations of functions implementing operations bis and bic */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bic</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compute x|y using only calls to functions bis and bic */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bool_or</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = __________;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Compute x^y using only calls to functions bis and bic */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bool_xor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = __________;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-8-C-语言中的逻辑运算"><a href="#2-1-8-C-语言中的逻辑运算" class="headerlink" title="2.1.8 C 语言中的逻辑运算"></a>2.1.8 C 语言中的逻辑运算</h2><p>C 语言还提供了一组逻辑运算符 ||、&amp;&amp; 和 ！，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。以下是一些表达式求值的示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表达式</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">!0x41</td>
<td style="text-align:center">0x00</td>
</tr>
<tr>
<td style="text-align:left">!0x00</td>
<td style="text-align:center">0x01</td>
</tr>
<tr>
<td style="text-align:left">!!0x41</td>
<td style="text-align:center">0x01</td>
</tr>
<tr>
<td style="text-align:left">0x68&amp;&amp;0x55</td>
<td style="text-align:center">0x01</td>
</tr>
<tr>
<td style="text-align:left">0x69 &#124;&#124; 0x55</td>
<td style="text-align:center">0x01</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，按位运算只有在特殊情况下，也就是参数被限制为 0 或者 1 时，才和与其对应的逻辑运算有相同的行为。</p>
<p>逻辑运算符 &amp;&amp; 和 || 与它们对应的位级运算 &amp; 和 | 之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，例如，表达式 a&amp;&amp;5/a 将不会造成被零除，而表达式 p&amp;&amp;*p++ 也不会导致间接引用空指针。</p>
<ul>
<li>✍ <code>练习题2.14</code> 假设 x 和 y 的字节值分别为 0x66 和 0x39。填写下表，指明各个 C 表达式的字节值。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">值</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x &amp; y</td>
<td style="text-align:center"></td>
<td style="text-align:center">x &amp;&amp; y</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">x &#124; y</td>
<td style="text-align:center"></td>
<td style="text-align:center">x &#124;&#124; y</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">~x &#124; ~y</td>
<td style="text-align:center"></td>
<td style="text-align:center">!x &#124;&#124; !y</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">x &amp; !y</td>
<td style="text-align:center"></td>
<td style="text-align:center">x &amp;&amp; ~y</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>✍ <code>练习题2.15</code> 只使用位级和逻辑运算，编写一个 C 表达式，它等价于 x==y。换句话说，当 x 和 y 相等时它将返回1，否则就返回0。</li>
</ul>
<h2 id="2-1-9-C-语言中的移位运算"><a href="#2-1-9-C-语言中的移位运算" class="headerlink" title="2.1.9 C 语言中的移位运算"></a>2.1.9 C 语言中的移位运算</h2><p>C 语言还提供了一组<code>移位</code>运算，向左或者向右移动位模式。对于一个位表示为 $[x_{w-1},x_{w-2},\cdots,x_0]$ 的操作数$x$，C 表达式 $x&lt;&lt;k$ 会生成一个值，其位表示为 $[x_{w-k-1},x_{w-k-2},\cdots,x_0,0,\cdots,0]$。也就是说，x向左移动 $k$ 位，丢弃最高的 $k$ 位，并在右端补 $k$ 个 0。移位量应该是一个 0~w—1 之间的值。移位运算是从左至右可结合的，所以 $x&lt;&lt;j&lt;&lt;k$ 等价于 $(x&lt;&lt;j)&lt;&lt;k$。</p>
<p>有一个相应的右移运算 $x&gt;&gt;k$，但是它的行为有点微妙。一般而言，机器支持两种形<br>式的右移：<code>逻辑右移</code>和<code>算术右移</code>。逻辑右移在左端补 $k$ 个 0，得到的结果是$[0,\cdots,0,x_{w-1},x_{w-2},\cdots,x_k]$。算术右移是在左端补 $k$ 个最高有效位的值，得到的结果是 $[x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\cdots,x_k]$。这种做法看上去可能有点奇特，但是我们会发现它对有符号整数数据的运算非常有用。</p>
<p>让我们来看一个例子，下面的表给出了对一个 8 位参数 x 的两个不同的值做不同的移位操作得到的结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">参数x</td>
<td style="text-align:center">[01100011] [10010101]</td>
</tr>
<tr>
<td style="text-align:center">x &lt;&lt; 4</td>
<td style="text-align:center">[0011<em>0000</em>] [0101<em>0000</em>]</td>
</tr>
<tr>
<td style="text-align:center">x &gt;&gt; 4 （逻辑右移）</td>
<td style="text-align:center">[<em>0000</em>0110] [<em>0000</em>1001]</td>
</tr>
<tr>
<td style="text-align:center">x &gt;&gt; 4 （算术右移）</td>
<td style="text-align:center">[<em>0000</em>0110] [<em>1111</em>1001]</td>
</tr>
</tbody>
</table>
</div>
<p>斜体的数字表示的是最右端（左移）或最左端（右移）填充的值。可以看到除了一个条目之外，其他的都包含填充 0。唯一的例外是算术右移[10010101]的情况。因为操作数的最高位是1，填充的值就是1。</p>
<p>C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑<br>右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。</p>
<p>与 C 相比，Java 对于如何进行右移有明确的定义。表达是 $x&gt;&gt;k$ 会将 x 算术右移 k 个位置，而 $x&gt;&gt;&gt;k$ 会对x做逻辑右移。</p>
<blockquote>
<p><strong>旁注 移动K位，这里 K 很大</strong></p>
<p>对于一个由 $w$ 位组成的数据类型，如果要移动 $k \geqslant w$ 会得到什么结果呢？例如，计算下面的表达式会得到什么结果，假设数据类型 int为 $w=32$：</p>
<script type="math/tex; mode=display">
\begin{matrix}
int      &  lval = 0xFEDCBA98 << 32; \\
int      &  aval = 0xFEDCBA98 >> 36; \\
unsigned &  uval = 0xFEDCBA98u >> 40; \\
\end{matrix}</script><p>C 语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个 $w$ 位的值时，移位指令只考虑位移量的低 $\log_2 w$ 位，因此实际上位移量就是通过计算 $k \, mod \, w$ 得到的。例如，当$w=32$时，上面三个移位运算分别是移动0、4和8位，得到结果：</p>
<script type="math/tex; mode=display">
\begin{matrix}
lval & 0xFEDCBA98 \\
aval & 0xFFEDCBA9 \\
uval & OxOOFEDCBA \\
\end{matrix}</script><p>不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。<br>另一方面，Java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p>
<p><strong>旁注 与移位运算有关的操作符优先级问题</strong></p>
<p>常常有人会写这样的表达式 $1&lt;&lt;2+3&lt;&lt;4$，本意是 $(1&lt;&lt;2)+(3&lt;&lt;4)$。但是在 C 语言中，前面的表达式等价于 $1&lt;&lt;(2+3)&lt;&lt;4$，这是由于加法(和减法)的优先级比移位运算要高。然后，按照从左至右结合性规则，括号应该是这样打的 $(1&lt;&lt;(2+3))&lt;&lt;4$，得到的结果是 512 ,而不是期望的 52。</p>
<p>在 C 表达式中搞错优先级是一种常见的程序错误原因，而且常常很难检查出来。所以当你拿不准的时候，请加上括号！</p>
</blockquote>
<ul>
<li>✍ <code>练习题2.16</code> 填写下表，展示不同移位运算对单字节数的影响。思考移位运算的最好方式是使用二进制表示。将最初的值转换为二进制，执行移位运算，然后再转换回十六进制。每个答案都应该是8个二进制数字或者2个十六进制数字。</li>
</ul>
<p><img src="https://static01.imgkr.com/temp/50eb3e4deb7f4126a1394596371b303a.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://soarspaces.github.io/soarblog/soarblog/2021/03/29/CSAPP-chapter-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/soarblog/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肥肥小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/soarblog/2021/03/29/CSAPP-chapter-one/" itemprop="url">第一章 计算机系统漫游</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-29T17:47:15+08:00">
                2021-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/soarblog/categories/computer/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/soarblog/2021/03/29/CSAPP-chapter-one/" class="leancloud_visitors" data-flag-title="第一章 计算机系统漫游">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><center>计算机系统漫游</center></strong></p>
<hr>
<p><code>计算机系统</code>是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。</p>
<p>现在就要开始一次有趣的漫游历程了。如果你全力投身学习本书中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛”的道路。</p>
<p>你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。你将学会怎样通过一些小窍门来优化自己的 C 代码，以充分利用现代处理器和存储器系统的设计。你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。你将学会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。你将学会如何编写自己的 Unix shell、自己的动态存储分配包，甚至于自己的 Web 服务器。你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。</p>
<p>在<code>Kernighan</code>和<code>Ritchie</code>的关于 C 编程语言的经典教材中，他们通过图 1-1 中所示的 hello 程序来向读者介绍 C。尽管 hello 程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行 hello 程序时，系统发生了什么以及为什么会这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">———————————————————————————— code/intro/hello.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">———————————————————————————— code/intro/hello.c</span><br></pre></td></tr></table></figure>
<p>图 1-1 hello 程序</p>
<p>我们通过跟踪 hello 程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。</p>
<h1 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h1><p>hello程序的生命周期是从一个<code>源程序</code>（或者说<code>源文件</code>）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。</p>
<p>大部分的现代计算机系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的<a href="&quot;有其他编码方式用于表示非英语类语言文本。具体讨论参见2.1.4节的旁注。&quot;" title="其他编码">单字节大小的整数值</a>来表示每个字符。比如，图1-2 中给出了hello.c程序 的ASCII码表示。</p>
<p><img src="https://static01.imgkr.com/temp/79f20dd9bd2742eb8ae03ac83224bf4d.png" alt="图1-2 hello.c的ASCII文本表示"></p>
<p>hello.c 程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是35,它对应的就是字符 “#”。第二个字节的整数值为105,它对应的字符是‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符‘\n’来结束的，它所对应的整数值为10。像 hello.c 这样只由 ASCII 字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p>
<blockquote>
<p><strong>旁注 C 编程语言的起源</strong></p>
<p>C 语言是贝尔实验室的Dennis Ritchie于1969年〜1973年间创建的。美国国家标准学会 (American National Standards Institute, ANSI)在1989年颁布了 ANSI C 的标准，后来 C 语言的标准化成了国际标准化组织 (International Standards Organization，ISO) 的责任。这些标准定义了 C 语言和一系列函数库，即所谓的<code>C标准库</code>。Kernighan 和 Ritchie 在他们的经典著作中描述了 ANSI C，这本著作被人们满怀感情地称为 “K&amp;R”。用 Ritchie 的话来说，C 语言是“古怪的、有缺陷的，但同时也是一个巨大的成功”。为什么会成功呢？ </p>
<ul>
<li><strong>C语言与Unix操作系统关系密切</strong>。C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 内核(操作系统的核心部分)，以及所有支撑工具和函数库都是用C语言编写的。20世纪70年代后期到80年代初期，Unix 风行于高 等院校，许多人开始接触C语言并喜欢上它。因为 Unix 几乎全部是用C编写的，它可以很方便地移植到新的机器上，这种特点为 C 和 Unix 赢得了更为广泛的支持。</li>
<li><strong>C语言小而简单</strong>。C 语言的设计是由一个人而非一个协会掌控的，因此这是一个简洁明了、没有什么冗赘的设计。K&amp;R 这本书用大量的例子和练习描述了完整的 C 语言及其标准库，而全书不过261页。C 语言的简单使它相对而言易于学习，也易于移植到不同的计算机上。</li>
<li><strong>C语言是为实践目的设计的</strong>。C 语言是设计用来实现 Unix 操作系统的。后来，其他人发现能够用这门语言无障碍地编写他们想要的程序。</li>
</ul>
<p>C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成程序员困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象的显式支持，例如类、对象和异常。像 C++ 和 Java 这样针对应用级程序的新程序语言解决了这些问题。</p>
</blockquote>
<h1 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h1><p>hello 程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。</p>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>在这里，GCC 编译器驱动程序读取源程序文件 hello.c 并把它翻译成一个可执行目标文件 hello 这个翻译过程可分为四个阶段完成，如图1-3所示。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）。</p>
<p><img src="https://static01.imgkr.com/temp/197f0da67ee64d098803fa57bf4f44d6.png" alt="图1-3 编译系统"></p>
<ul>
<li><p><code>预处理阶段。</code>预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第1行的 #include<stdio.h> 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。</p>
</li>
<li><p><code>编译阶段。</code>编译器（ccl）将文本文件hello.i翻译成文本文件 hello.s，它包含一个汇编语言程序。该程序包含函数main的定义，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">  subq  $8, %rsp</span><br><span class="line">  movl  $.LCO, %edi</span><br><span class="line">  call  puts</span><br><span class="line">  movl  $0, %eax</span><br><span class="line">  addq  $8, %rsp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure></li>
<li><p>定义中2~7行的每行语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。</p>
</li>
<li><p><code>汇编阶段。</code>接下来，汇编器 (as) 将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序 (relocatable object program) 的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的17个字节是函数 main 的指令编码。如果我们在文本编辑器中打开 hello.o 文件，将看到一堆乱码。</p>
</li>
<li><p>·<code>链接阶段。</code>请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器 (Id) 就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件(或者简称为可执行文件)，可以被加载到内存中，由系统执行。</p>
</li>
</ul>
<hr>
<blockquote>
<p><strong>旁注 GNU项目</strong></p>
<p>GCC 是 GNU(GNU是GNU’s Not Unix的缩写) 项目开发出来的众多有用工具之一。GNU 项目是1984年由 Richard Stallman 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改和传播。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括EMACS编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括 C、C++、Fortran、Java、Pascal、面向对象C语言 (Objective-C) 和 Ada。</p>
<p>GNU 项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动(通常和Linux联系在一起)的思想起源是GNU项目中自由软件 (free software) 的概念。(此处的free<br>为自由言论 (free speech) 中的“自由”之意，而非免费啤酒(free beer)中的“免费”之意。)而且，Linux 如此受欢迎在很大程度上还要归功于 GNU 工具，它们给 Linux 内核提供了环境。</p>
</blockquote>
<h1 id="1-3-了解编译系统如何工作是大有益处的"><a href="#1-3-了解编译系统如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统如何工作是大有益处的"></a>1.3 了解编译系统如何工作是大有益处的</h1><p>对于像 hello.c 这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。</p>
<ul>
<li><p><code>优化程序性能。</code> 现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在 C 程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的 C 语句转化为机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else 语句高效得多？一个函数调用的开销有多大？ while 循环比 for 循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？<br>在第3章中，我们将介绍X86-64,最近几代 Linux、Macintosh 和 Windows 计算机的机器语言。我们会讲述编译器是怎样把不同的C语言结构翻译成这种机器语言的。在第5章中，你将学习如何通过简单转换 C 语言代码，帮助编译器更好地完成工作，从而调整 C 程序的性能。在第6章中，你将学习存储器系统的层次结构特性，C 语言编译器如何将数组存放在内存中，以及 C 程序又是如何能够利用这些知识从而更高效地运行。</p>
</li>
<li><p><code>理解链接时出现的错误。</code>根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？在第7章中，你将得到这些问题的答案。</p>
</li>
<li><p><code>避免安全漏洞。</code> 多年来，缓冲区溢出错误是造成大多数网络和 Internet 服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第3章中描述堆栈原理和缓冲区溢出错误。我们还将学习程序员、编译器和操作系统可以用来降低攻击威胁的方法。</p>
</li>
</ul>
<h1 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h1><p>此刻，hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello,并被存放在磁盘上。要想在 Unix 系统上运行该可执行文件，我们将它的文件名输入到称为 shell 的应用程序中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./hello</span></span><br><span class="line">hello, world</span><br><span class="line"><span class="meta">linux&gt;</span></span><br></pre></td></tr></table></figure><br>shell 是一个命令行解释器，它输出一个提示符，等待输人一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell将加载并运行 hello 程序，然后等待程序终止。hello 程序在屏幕上输出它的消息，然后终止。shell 随后输出一个提示符，等待下一个输人的命令行。</p>
<h2 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h2><p>为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组织，如<br>图1-4所示。这张图是近期 Intel 系统产品族的模型，但是所有其他系统也有相同的外观和特性。现在不要担心这张图很复杂——我们将在本书分阶段对其进行详尽的介绍。</p>
<ol>
<li><p><strong>总线</strong><br><br><br>贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传<br>递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。本书中，我们不对字长做任何固定的假设。相反，我们将在需要明确定义的上下文中具体说明一个“字”是多大。</p>
</li>
<li><p><strong>I/0设备</strong><br><br><br>I/0（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个I/O设<br>备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序<br>的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序 hello 就存放在磁盘上。<br><br>每个I/O设备都通过一个<code>控制器</code>或<code>适配器</code>与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。<br><br>第6章会更多地说明磁盘之类的I/O设备是如何工作的。在第10章中，你将学习如何在应用程序中利用 Unix I/O接口访问设备。我们将特别关注网络类设备，不过这些技术对于其他设备来说也是通用的。</p>
</li>
</ol>
<p><img src="https://static01.imgkr.com/temp/20880fa56f2943a69caf3ed1d3d9a061.png" alt="图1-4 一个典型系统的硬件组成"></p>
<p><code>cpu：中央处理单元；ALU：算术/逻辑单元；PC：程序计数器；USB：通用串行总线</code></p>
<ol>
<li><p><strong>主存</strong><br><br><br>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从<br>物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与 C 程序变量相对应的数据项的大小是根据类型变化的。比如，在运行 Linux 的x86-64机器上，short 类型的数据需要2个字节，int 和 float 类型需要4个字节，而 long 和 double 类型需要8个字节。<br><br><br>第6章将具体介绍存储器技术，比如 DRAM 芯片是如何工作的，它们又是如何组合起来构成主存的。</p>
</li>
<li><p><strong>处理器</strong><br><br><br>中央处理单元（CPU）,简称<code>处理器</code>，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或<code>寄存器</code>），称为<code>程序计数器</code>（PC）。在任何时刻，<a href="&quot;pc也普遍地被用来作为“个人计算机”的缩写。然而，两者之间的区别应该可以很清楚地从上下文中看出来。&quot;" title="PC">PC</a>都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br><br><br>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。<br><br><br>这样的简单操作并不多，它们围绕着<code>主存</code>、<code>寄存器文件</code>(register file)和<code>算术/逻辑单元</code>(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个<br>寄存器都有唯一的名字。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。</p>
</li>
</ol>
<ul>
<li><strong>加载</strong>：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。 </li>
<li><strong>存储</strong>：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li><strong>操作</strong>：把两个寄存器的内容复制到 ALU, ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制到程序计数器 (PC) 中，以覆盖PC中原来的值。</li>
</ul>
<p>处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂<br>的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分<br>开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际<br>上是如何实现的。在第3章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽<br>象性。第4章将更详细地介绍处理器实际上是如何实现的。第5章用一个模型说明现代处<br>理器是如何工作的，从而能预测和优化机器语言程序的性能。</p>
<h2 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h2><p>前面简单描述了系统的硬件组成和操作，现在开始介绍当我们运行示例程序时到底发生了些什么。在这里必须省略很多细节，稍后会做补充，但是现在我们将很满意于这种整体上的描述。</p>
<p>初始时，shell 程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串<br>“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到内存中，如图1-5所示。</p>
<p><img src="https://static01.imgkr.com/temp/cf4bab5a89154842bac1b22695cbd2dd.png" alt="图1-5 从键盘上读取hello命令"></p>
<p>当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出成字符串“hello, world\n”。</p>
<p>利用直接存储器存取（DMA,将在第6章中讨论）技术，数据可以不通过处理器而直<br>接从磁盘到达主存。这个步骤如图1-6所示。</p>
<p><img src="https://static01.imgkr.com/temp/3b431233e8534c99807d08b5137f1c5c.png" alt="图1-6 从磁盘加载可执行文件到主存"></p>
<p>一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的main程序中的机器语言指令。这些指令将 “hello, world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如图1-7所示。</p>
<p><img src="https://static01.imgkr.com/temp/255346a57b2a4db09158e8b5e578d977.png" alt="图1-7 将输出字符串从存储器写到显示器"></p>
<h1 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h1><p>这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。hello 程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复制到主存；当处理器运行程序时，指令又从主存复制到处理器。相似地，数据串 “hello,world/n” 开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备。从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。</p>
<p>根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍。</p>
<p>类似地，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。</p>
<p>针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为<code>高速缓存存储器</code>（cache memory,简称为 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。图1-8展示了一个典型系统中的高速缓存存储器。位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。</p>
<p>一个容量为数十万到数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5〜10倍。L1和L2高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：LI、L2和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p>
<p><img src="https://static01.imgkr.com/temp/aec883c239dc4050af5bb3b4112fc931.png" alt="图1-8 高速缓存存储器"></p>
<p>本书得出的重要结论之一就是，意识到<code>高速缓存存储器</code>存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。你将在第6章里学习这些重要的设备以及如何利用它们。</p>
<h1 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h1><p>在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，如图1-9所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为L0。这里我们展示的是三层高速缓存L1到L3,占据存储器层次结构的第1层到第3层。主存在第4层，以此类推。</p>
<p><img src="https://static01.imgkr.com/temp/0955c089e1524372885caddca9323342.png" alt="图1-9 一个存储器层次结构的示例"></p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。</p>
<p>正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。第6章将更详细地讨论这个问题。</p>
<h1 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h1><p>让我们回到 hello 程序的例子。当 shell 加载和运行hello程序时，以及 hello 程序输出自己的消息时，shell 和 hello 程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如图1-10所示。所有应用程序对硬件的操作尝试都必须通过操作系统。</p>
<p><img src="https://static01.imgkr.com/temp/15c815d24d714827b8c777363b62a09d.png" alt="图1-10 计算机系统的分层视图"></p>
<p>操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序<br>提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个<br>基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。如图1-11所示，文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理<br>器、主存和I/O设备的抽象表示。我们将依次讨论每种抽象表示。</p>
<p><img src="https://static01.imgkr.com/temp/7f39fda6051d48dfbb93fefba4217977.png" alt="图1-11 操作系统提供的抽象表示"></p>
<blockquote>
<p><strong>旁注 Unix、Posix和标准Unix规范</strong></p>
<p>20世纪60年代是大型、复杂操作系统盛行的年代，比如IBM的 OS/360 和 Honeywell的 Multics 系统。OS/360 是历史上最成功的软件项目之一，而 Multics 虽然持续存在了多年，却从来没有被广泛应用过。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为考虑到该项目的复杂性和缺乏进展而于1969年退出。鉴于Mutics项目不愉快的经历，一群贝尔实验室的研究人员———— Ken Thompson、Dennis Ritchie、Doug Mcllroy 和Joe Ossanna,从1969年开始在DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的操作系统。这个新系统中的很多思想，比如层次文件系统、作为用户级进程的shell概念，都是来自于Multics,只不过在一个更小、更简单的程序包里实现。1970年，Brian Kernighan 给新系统命名为 “Unix”，这也是一个双关语，暗指 “Multics” 的复杂性。1973年用 C 重新编写其内核，1974年，Unix 开始正式对外发布［93］。</p>
<p>贝尔实验室以慷慨的条件向学校提供源代码，所以 Unix在大专院校里获得了很多支持并得以持续发展。最有影响的工作发生在20世纪70年代晚期到80年代早期，在美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和Internet协议，称为 Unix 4. xBSD(Berkeley Software Distribution)。与此同时，贝尔实验室也在发布自己的版本，称为 System V Unix。其他厂商的版本，比如Sun Microsystems的 Solaris 系统，则是从这些原始的 BSD 和 System V 版本中衍生而来。</p>
<p>20世纪80年代中期，Unix 厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同，麻烦也就随之而来了。为了阻止这种趋势，IEEE (电气和电子工程师协会)开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为“Posix”。结果就得到了一系列的标准，称作Posix标准。这套标准涵盖了很多方面，比如Unix系统调用的 C 语言接口、shell 程序和工具、线程及网络编程。最近，一个被称为“标准Unix规范”的独立标准化工作已经与 Posix —起创建了统一的 Unix 系统标准。这些标准化工作的结果是Unix版本之间的差异已经基本消失。</p>
</blockquote>
<h2 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h2><p>像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I/O设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p>
<p><code>进程</code>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而<code>并发运行</code>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的<code>多核</code>处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为<code>上下文切换</code>。为了简化讨论，我们只考虑包含一个CPU的<code>单处理器系统</code>的情况。我们会在1.9.2节中讨论<code>多处理器系统</code>。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<code>上下文</code>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。图1-12展示了示例hello程序运行场景的基本理念。</p>
<p>示例场景中有两个并发的进程：shell进程和hello进程。最开始，只有shell进程在运行，即等待命令行上的输人。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回<br>给它，shell进程会继续等待下一个命令行输人。</p>
<p>如图1-12所示，从一个进程到另一个进程的转换是由操作系统<code>内核(kernel)</code>管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的<code>系统调用(systemcall)</code>指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p>
<p><img src="https://static01.imgkr.com/temp/4bb5d79fde224c5384fca2bf08fa8343.png" alt="图1-12 进程的上下文切换"></p>
<p>实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。我们将在第8章中揭示这项工作的原理，以及应用程序是如何创建和控制它们的进程的。</p>
<h2 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h2><p>尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在1.9.2节中讨论这个问题。在第12章中，你将学习并发的基本概念，包括如何写线程化的程序。</p>
<h2 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h2><p><code>虚拟内存</code>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为<code>虚拟地址空间</code>。图1-13所示的是Linux进程的虚拟地址空间（其他Unix系统的设计也与此类似）。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。</p>
<p><img src="https://static01.imgkr.com/temp/2705deeb10454235ad718446256e15d2.png" alt="图1-13 进程的虚拟地址空间"></p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。在本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益的。我们从最低的地址开始，逐步向上介绍。</p>
<ul>
<li><code>程序代码和数据。</code>对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。在第7章我们研究链接和加载时，你会学习更多有关地址空间的内容。</li>
<li><code>堆。</code>代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。在第9章学习管理虚拟内存时，我们将更详细地研究堆。</li>
<li><code>共享库。</code>大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。在第7章介绍动态链接时，将学习共享库是如何工作的。</li>
<li><code>栈。</code>位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。在第3章中将学习编译器是如何使用栈的。</li>
<li><code>内核虚拟内存。</code>地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li>
</ul>
<p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。<em>基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</em> 第9章将解释它如何工作，以及为什么对现代系统的运行如此重要。</p>
<h2 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h2><p><code>文件</code>就是字节序列，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O的系统函数调用读写文件来实现的。</p>
<p>文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O 设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。你将在第10章中学习 Unix I/O。</p>
<blockquote>
<p><strong>旁注 Linux项目</strong></p>
<p>1991年8月，芬兰研究生 Linus Torvalds 谨慎地发布了一个新的类Unix的操作系统内核，内容如下。</p>
<p>来自：torvalds@klaava.Helsinki.FK(Linus Benedict Torvalds)</p>
<p>新闻组：comp.os.minix</p>
<p>主题：在minix中你最想看到什么？</p>
<p>摘要：关于我的新操作系统的小调查</p>
<p>时间：1991年8月25日20:57:08GMT</p>
<p>每个使用 minix 的朋友，你们好。</p>
<p>我正在做一个(免费的)用在386(486)AT上的操作系统(只是业余爱好，它不会像GNU那样庞大和专业)。这个想法自4月份就开始酝酿，现在快要完成了。我希望得到各位对minix的任何反馈意见，因为我的操作系统在某些方面与它相类似(其中包括相同的文件系统的物理设计(因为某些实际的原因))。</p>
<p>我现在已经移植了 bash(1.08) 和 gcc(1.40)，并且看上去能运行。这意味着我需要几个月的时间来让它变得更实用一些，并且，我想要知道大多数人想要什么特性。欢迎任何建议，但是我无法保证我能实现它们。:-)</p>
<p>Linus(torvalds@kruuna.helsinki.fi)</p>
<p>就像 Torvalds 所说的，他创建 Linux 的起点是 Minix,由 Andrew S.Tanenbaum出于教育目的开发的一个操作系统。</p>
<p>接下来，如他们所说，这就成了历史。Linux逐渐发展成为一个技术和文化现象。通过和 GNU 项目的力量结合，Linux 项目发展成了一个完整的、符合 Posix 标准的 Unix 操作系统的版本，包括内核和所有支撑的基础设施。从手持设备到大型计算机，Linux 在范围如此广泛的计算机上得到了应用。IBM 的一个工作组甚至把Linux移植到了一块腕表中！</p>
</blockquote>
<h1 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h1><p>系统漫游至此，我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上，现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备，如图1-14所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="https://static01.imgkr.com/temp/f4c403dcd4074e8a9367cdcfb6009a9c.png" alt="图1-14 网络也是一种I/O设备"></p>
<p>随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和 telnet 这样的应用都是基于网络复制信息的功能。</p>
<p>回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello 程序。假设用本地主机上的 <code>telnet 客户端</code>连接远程主机上的 <code>telnet 服务器</code>。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输人命令。此后在远端运行 hello 程序包括如图1-15所示的五个基本步骤。</p>
<p><img src="https://static01.imgkr.com/temp/3a7ea55c8c054ba1b700a86f37b2c766.png" alt="图1-15 利用telnet通过网络远程运行hello"></p>
<p>当我们在telnet客户端键人“hello”字符串并敲下回车键后，客户端软件就会将这个字符串发送到telnet的服务器。telnet服务器从网络上接收到这个字符串后，会把它传递给远端shell程序。接下来，远端shell运行hello程序，并将输出行返回给telnet服务器。最后，telnet服务器通过网络把输出串转发给telnet客户端，客户端就将输出串输出到我们的本地终端上。</p>
<p>这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。在第11章中，你将学会如何构造网络应用程序，并利用这些知识创建一个简单的 Web 服务器。</p>
<h1 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h1><p>在此，小结一下我们旋风式的系统漫游。这次讨论得出一个很重要的观点，那就是系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。本书的余下部分会讲述硬件和软件的详细内容，通过了解这些详细内容，你可以写出更快速、更可靠和更安全的程序。</p>
<p>作为本章的结束，我们在此强调几个贯穿计算机系统所有方面的重要概念。我们会在本书中的多处讨论这些概念的重要性。</p>
<h2 id="1-9-1-Amdahl-定律"><a href="#1-9-1-Amdahl-定律" class="headerlink" title="1.9.1 Amdahl 定律"></a>1.9.1 Amdahl 定律</h2><p>Gene Amdahl,计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察被称为 Amdahl 定律 (Amdahl’s law)。该定律的主要思想是，当我们对系 统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为 $T_{old}$ 。假设系统某部分所需执行时间与该时间的比例为 $\alpha$，而该部分性能提升比例为 $\kappa$。 即该部分初始所需时间为 $\alpha\,T_{old}$,现在所需时间为 $\alpha\,T_{old}/\kappa$因此，总的执行时间应为</p>
<script type="math/tex; mode=display">T_{new}\,=\,(1-\alpha) T_{old}\,+\,\alpha T_{old}/\kappa\,=\,T_{old}\,[(1-\alpha)\,+\,\alpha/\kappa]</script><p>由此，可以计算加速比 $ S = T_{old}/T_{new}$ 为</p>
<script type="math/tex; mode=display">S\;=\; \frac {1} {(1-\alpha)\,+\,\alpha/\kappa}</script><p>举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为 60%(α=0.6),其加速比例因子为3(κ=3)。则我们可以获得的加速比为 1/[0.4+0.6/3]=1.67倍。虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是 Amdahl 定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p>
<blockquote>
<p><strong>旁注 表示相对性能</strong></p>
<p>性能提升最好的表示方法就是用比例的形式 $T_{old}/T_{new}$，其中，$T_{old}$ 为原始系统所需时间，$T_{new}$ 为修改后的系统所需时间。如果有所改进，则比值应大于1。我们用后缀“Х”来表示比例，因此，“2.2Х” 读作 “2.2倍”。</p>
<p>表示相对变化更传统的方法是用百分比，这种方法适用于变化小的情况，但其定义是模糊的。应该等于 $100 \cdot (T_{old}-T_{new})/T_{new}$，还是$100 \cdot (T_{old}-T_{new})/T_{old}$，还是其他的值？此外，它对较大的变化也没有太大意义。与简单地说性能提升2.2X相比，“性能提升了120%”更难理解。</p>
</blockquote>
<ul>
<li>✍ <code>练习题1.1</code> 假设你是个卡车司机，要将土豆从爱达荷州的 Boise 运送到明尼苏达州的 Minneapolis,全程2500公里。在限速范围内，你估计平均速度为100公里/小时，整个行程需要25个小时。<ul>
<li>A.你听到新闻说蒙大拿州刚刚取消了限速，这使得行程中有1500公里卡车的速度可以为150公里/小时。那么这对整个行程的加速比是多少？</li>
<li>B.你可以在 www.fasttrucks.com 网站上为自己的卡车买个新的涡轮增压器。网站现货供应各种型号，不过速度越快，价格越高。如果想要让整个行程的加速比为1.67X,那么你必须以多快的速度通过蒙大拿州？</li>
</ul>
</li>
<li>✍<code>练习题1.2</code> 公司的市场部向你的客户承诺，下一个版本的软件性能将改进2X。这项任务被分配给你。你已经确认只有80%的系统能够被改进，那么，这部分需要被改进多少(即κ取何值)才能达到整体性能目标？</li>
</ul>
<p>Amdahl定律一个有趣的特殊情况是考虑 κ 趋向于∞时的效果。这就意味着，我们可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。<br>于是我们得到</p>
<script type="math/tex; mode=display">S_\infty \;=\; \frac {1}{(1-\alpha)}</script><p>举个例子，如果 60% 的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有 1/0.4=2.5X。</p>
<p>Amdahl定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低刀片制造成本，或学生想要提高自己的绩点平均值等方面。也许它在计算机世界里是最有意义的，在这里我们常常把性能提升2倍或更高的比例因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。</p>
<h2 id="1-9-2-并发与并行"><a href="#1-9-2-并发与并行" class="headerlink" title="1.9.2 并发与并行"></a>1.9.2 并发与并行</h2><p>数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的术语<code>并发(concurrency)</code>是一个通用的概念，指一个同时具有多个活动的系统；而术语<code>并行(parallelism)</code>指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。</p>
<ol>
<li><strong>线程级并发</strong><br><br><br>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。自20世纪60年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。这种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个Web服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启Web浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为<code>单处理器系统</code>。<br><br><br>当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个<code>多处理器系统</code>。其实从20世纪80年代开始，在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和<code>超线程(hyperthreading)</code>的出现，这种系统才变得常见。图1-16给出了这些不同处理器类型的分类。</li>
</ol>
<p><img src="https://static01.imgkr.com/temp/574db1150bb842b0ba4a4db004bc022b.png" alt="图1-16 不同的处理器配置分类。随着多核处理器和超线程的出现，多处理器变得普遍了"></p>
<p>多核处理器是将多个CPU(称为“核”)集成到一个集成电路芯片上。图1-17 描述的是一个典型多核处理器的组织结构，其中微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中的L1高速缓存分为两个部分———— 一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能够将几十个、最终会是上百个核做到一个芯片上。</p>
<p><img src="https://static01.imgkr.com/temp/f24237d57c444a8a91a48c4dc36829a7.png" alt="图1-17 多核处理器的组织结构。4个处理器核集成在一个芯片上"></p>
<p>超线程，有时称为<code>同时多线程(simultaneous multi-threading)</code>,是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。举例来说，Intel Core i7 处理器可以让每个核执行两个线程，所以一个4核的系统实际上可以并行地执行8个线程。</p>
<p>多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过50年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。第12章会更深人地探讨并发，以及使用并发来提供处理器资源的共享，使程序的执行允许有更多的并行。</p>
<ol>
<li><p>指令级并行<br><br><br>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，如 1978 年的 Intel 8086,需要多个(通常是3~10个)时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期2~4条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约20个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达100条指令。在第4章中，我们会研究<code>流水线(pipelining)</code>的使用。在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的执行速率。<br><br><br>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量(superscalar)处理器。大多数现代处理器都支持超标量操作。第5章中，我们将描述超标量处理器的高级模型。应用程序员可以用这个模型来理解程序的性能。然后，他们就能写出拥有更高程度的指令级并行性的程序代码，因而也运行得更快。</p>
</li>
<li><p>单指令、多数据并行<br><br><br>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为<code>单指令、多数据</code>，即 SIMD 并行。例如，较新几代的Intel和AMD处理器都具有并行地对8对单精度浮点数( C数据类型 float )做加法的指令。<br><br><br>提供这些 SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从 C 程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。作为对第5章中比较通用的程序优化描述的补充，我们在网络旁注 OPT:SIMD 中描述了这种编程方式。</p>
</li>
</ol>
<h1 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h1><p><code>抽象</code>的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口(API)就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如Java类的声明和C语言的函数原型。</p>
<p>我们已经介绍了计算机系统中使用的几个抽象，如图1-18所示。在处理器里，<code>指令集架构</code>提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。</p>
<p><img src="https://static01.imgkr.com/temp/a9e7f121bf9d4b5580b0c9f94106c83b.png" alt="图1-18 计算机系统提供的一些抽象。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性"></p>
<p>在学习操作系统时，我们介绍了三个抽象：文件是对 I/O 设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象：虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是IBM在20世纪60年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统 (例如，MicrosoftWindows、MacOS 和 Linux) 或同一操作系统的不同版本设计的程序。</p>
<p>在本书后续的章节中，我们会具体介绍这些抽象。</p>
<h1 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h1><p>计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。</p>
<p>处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构—— CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化 C 程序的性能。</p>
<p>操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1) 文件是对I/O 设备的抽像；2) 虚拟内存是对主存和磁盘的抽象；3) 进程是处理器、主存和 I/O 设备的抽象。</p>
<p>最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O设备。</p>
<h3 id="练习题答案"><a href="#练习题答案" class="headerlink" title="练习题答案"></a>练习题答案</h3><ol>
<li>1 该问题说明Amdahl定律不仅仅适用于计算机系统。<ul>
<li>A. 根据公式1.1，有 α = 0.6, κ = 1.5。更直接地说，在蒙大拿行驶的1500公里需要10个小时，而其他行程也需要10个小时。则加速比为 25/(10+10) = 1.25X。</li>
<li>B. 根据公式1.1 ,有 α = 0.6，要求 S = l.67，则可算出κ。更直接地说，要使行程加速度达到1.67X，我们必须把全程时间减少到15个小时。蒙大拿以外仍要求为10小时，因此，通过蒙大拿的时间就为5个小时。这就要求行驶速度为300公里/小时，对卡车来说这个速度太快了！</li>
</ul>
</li>
<li>2 理解 Amdahl 定律最好的方法就是解决一些实例。本题要求你从特殊的角度来看公式1.1。<br><br><br>本题是公式的简单应用。已知 S = 2， α = 0.8，则计算κ：<script type="math/tex; mode=display">\qquad\qquad\quad\quad 2 \;=\; \frac {1}{(1 - 0.8) \, + \, 0.8/\kappa}</script><script type="math/tex; mode=display">\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\! 0.4 + 1.6 / \kappa \; = \; 1.0</script><script type="math/tex; mode=display">\kappa \; = \; 2.67</script></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/soarblog/images/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!-- <a href="/soarblog/archives/%7C%7Carchive">-->
				<a href="/soarblog/archives">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/soarblog/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/soarblog/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">soar spaces</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/soarblog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/soarblog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/soarblog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/soarblog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/soarblog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/soarblog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/soarblog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  













<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
 


  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("vxRHngT8QMETbXIgL4WQIX5h-gzGzoHsz", "aFEhragJAcBUbaKWXqQIxWB2");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
